{% block content %}

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Spectrum and Water fall</title>
    <link rel="preload" href="{{ url_for('static', filename='css/bootstrap_4_lcjs.min.css')}}" as="style" />
    <link rel="preload" href="{{ url_for('static', filename='js/lcjs.iife.js')}}" as="script" />
    <link rel="stylesheet" type="text/css" href="{{ url_for('static', filename='css/bootstrap_4_lcjs.min.css')}}" />
    <link rel="stylesheet" type="text/css" href="{{ url_for('static', filename='css/font-awsome-4.7.min.css')}}" />
    <link rel="stylesheet" type="text/css" href="{{ url_for('static', filename='css/openwebrx.css')}}" />
    <link rel="stylesheet" href="{{ url_for('static', filename='css/fontawesome.all.min.css')}}">
    <link rel="stylesheet" href="{{ url_for('static', filename='css/fontawesome.min.css')}}">
    <style>
        #lcjs-auto-flexbox{
            background-color: transparent;
            will-change: transform;
            }

        canvas{
            background-color: transparent;
            will-change: transform;
            }
        body{
            background-color: transparent;
            }

        .full-screen-div {
            position: absolute;
            color: rgb(0, 0, 0);
            top: 38px;
            right: 29px;
            z-index: 1001;
            height: 25px;
            width: 25px;
        }

        .screen-shot-div {
            position: absolute;
            color: rgb(0, 0, 0);
            top: 38px;
            right: 42px;
            z-index: 1001;
            height: 25px;
            width: 25px;
        }

        #trace_dwn {
            position: absolute;
            top: 15px;
            right: 30px;
            z-index: 1001;
        }

        #trace_up {
            position: absolute;
            top: 15px;
            right: 30px;
            z-index: 1001;
        }

        #outer_trace {
            padding-top: 2px;
        }

        #custom-legend {
            background:rgb(0, 0, 0, 38%);
            padding: 10px;
            border: 1px solid #FFFFFF;
            color: white;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.2);
            position: absolute;
            top: 22px;
            right: 30px;
            z-index: 1000;
            height: 210px;
            width: 116px;
            transition: width 0.3s ease, height 0.3s ease, background-color 0.3s ease;
        }

        #custom_legend_camera {
            background: transparent;
            padding: 5px;
            border-radius: 5px;
            color: white;
            position: absolute;
            left: 0px;
            bottom: 0px;
            z-index: 1000;
            height: auto;
            width: auto;
        }

        .legend-item {
            display: flex;
            align-items: center;
            margin-bottom: 5px;
            font-size: small;
        }

        .legend-checkbox {
            appearance: none;
            -webkit-appearance: none;
            -moz-appearance: none;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            border: 2px solid #ccc;
            outline: none;
            cursor: pointer;
            margin-right: 8px;
            position: relative;
        }

        .legend-checkbox:checked::after {
            content: "";
            display: block;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background-color: #d79c3c;
            position: absolute;
        }

        .openwebrx-dialog {
            background-color: #0e1011;
        }

        .openwebrx-text {
            font-weight: bolder;
            font-family: "Roboto", "Helvetica Neue", Arial, sans-serif;
        }

        /* Performance optimized animations */
        .fade-in {
            animation: fadeIn 0.3s ease-in;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        /* GPU acceleration for better performance */
        .gpu-accelerated {
            transform: translateZ(0);
            backface-visibility: hidden;
            perspective: 1000;
        }
    </style>
    <!-- Optimized script loading with async/defer -->
    <script>
        // Performance configuration constants
        const PERFORMANCE_CONFIG = {
            MAX_DATA_POINTS: 8192,
            UPDATE_THROTTLE_MS: 33, // ~30 FPS
            CLEANUP_INTERVAL_MS: 10000,
            MAX_CIRCULAR_BUFFER_SIZE: 500,
            DEBOUNCE_DELAY_MS: 200,
            ANIMATION_FRAME_BUDGET_MS: 16
        };

        // DOM element cache
        const DOM_CACHE = {
            elements: new Map(),
            get(id) {
                if (!this.elements.has(id)) {
                    this.elements.set(id, document.getElementById(id));
                }
                return this.elements.get(id);
            },
            clear() {
                this.elements.clear();
            }
        };
    </script>
    <!-- Load critical scripts first -->
    <script defer src="{{ url_for('static', filename='js/lcjs.iife.js')}}"></script>
    <!-- Load other scripts asynchronously -->
    <script async src="{{ url_for('static', filename='js/bootstrap.bundle_4_lcjs.min.js')}}"></script>
    <script async src="{{ url_for('static', filename='lib/jquery/jquery.js')}}"></script>
    <script async src="{{ url_for('static', filename='lib/popper.js/popper.js')}}"></script>
    <script async src="{{ url_for('static', filename='lib/bootstrap/bootstrap.js')}}"></script>
    <script async src="{{ url_for('static', filename='bootstrap/bootstrap.min.js')}}"></script>
    <script async src="{{ url_for('static', filename='lib/perfect-scrollbar/js/perfect-scrollbar.jquery.js')}}"></script>
    <script async src="{{ url_for('static', filename='lib/moment/moment.js')}}"></script>
    <script async src="{{ url_for('static', filename='js/moment.min.js')}}"></script>
    <script async src="{{ url_for('static', filename='js/fontawesome.all.min.js')}}"></script>
    <script async src="{{ url_for('static', filename='js/fontawesome.min.js')}}"></script>
    <script async src="{{ url_for('static', filename='lib/jquery-ui/jquery-ui.js')}}"></script>
</head>

<body>
    <!-- Optimized modal with reduced opacity transitions -->
    <div class="modal modal-backdrop fade" id="websocket_loader" tabindex="-1" role="dialog" aria-labelledby="MultipleDeleteTargetModelLabel">
        <div class="modal-dialog modal-dialog-centered text-center" role="document">
            <div class="modal-body">
                <div class="m-0 px-0 py-5" style="background-color:white">
                    <i class="fa fa-spinner fa-spin fa-4x" style="color:black"></i>
                </div>
            </div>
        </div>
    </div>

    <!-- Full screen controls with GPU acceleration -->
    <div class="full-screen-div ml-1 gpu-accelerated">
        <div class="">
            <label for="full_screen" class="full_screen uil uil-expand-arrows-alt" id="full_screen_label"
                style="color: #ffffff; cursor: pointer;" onclick="optimizedFullScreen()">
                <i style='font-size:15px' data-bs-toggle="tooltip" data-bs-placement="left" title="Full Screen"
                    class='fas fa-expand-arrows-alt'></i>
            </label>
        </div>
    </div>

    <!-- Custom legend with performance optimizations -->
    <div id="custom-legend" class="gpu-accelerated">
        <div id="outer_trace">
            <label for="" id="traces_label">Traces</label>
            <i class="fa fa-caret-down" id="trace_dwn" style="display: block;" onclick="optimizedCollapseTrace('dwn')"></i>
            <i class="fa fa-caret-up" id="trace_up" style="display:none;" onclick="optimizedCollapseTrace('up')"></i>

            <div id="tracemenu" style="display:none;">
                <div class="legend-item">
                    <input type="checkbox" class="legend-checkbox" id="main_curve" onclick="optimizedShowMainCurve()">
                    <label for="main_curve" class="main_curve" style="color: green;" id="main_curve_label">Main-Curve</label>
                </div>
                <div class="legend-item">
                    <input type="checkbox" class="legend-checkbox" id="avg_hold" checked onclick="optimizedShowTracesAvg()">
                    <label for="avg_hold" class="avg_hold" id="avg_hold_label">Avg-hold</label>
                </div>
                <div class="legend-item">
                    <input type="checkbox" class="legend-checkbox" id="max_hold" onclick="optimizedShowTracesMax()">
                    <label for="max_hold" class="max_hold" style="color: #8300c4;">Max-Hold</label>
                </div>
                <div class="legend-item">
                    <input type="checkbox" class="legend-checkbox" id="min_hold" onclick="optimizedShowTracesMin()">
                    <label for="min_hold" class="min_hold" style="color: #37a6de">Min-Hold</label>
                </div>
                <div class="legend-item">
                    <input type="checkbox" class="legend-checkbox" id="persistence_data_btn" checked onclick="optimizedShowTracesPersis()">
                    <label for="persistence_data_btn" class="peak_data_btn" style="color: red;">Persistence</label>
                </div>
                <div class="legend-item">
                    <input type="checkbox" class="legend-checkbox" id="peak_data_btn" checked onclick="optimizedShowPeakData()">
                    <label for="peak_data_btn" class="peak_data_btn" style="color: #66cc35;">Peaks</label>
                </div>
                <div class="legend-item">
                    <input type="checkbox" class="legend-checkbox" id="mark_data_btn" checked onclick="optimizedShowMarkData()">
                    <label for="mark_data_btn" id="marker_color_label" class="mark_data_btn" style="color:#d7d6db">Markers</label>
                </div>
                <div class="legend-item">
                    <input type="checkbox" class="legend-checkbox" id="band" checked onclick="optimizedShowTracesBand()">
                    <b><label for="band" id="band_label" class="mark_data_btn" style="color:#ff7800">Demod</label></b>
                </div>
            </div>
        </div>
    </div>

    <!-- Camera controls with optimized event handling -->
    <div id="custom_legend_camera" class="gpu-accelerated">
        <button style="color: white;background-color: transparent;border: 0px solid;" title="Screenshot" id="screenshot_img">
            <i class="fa fa-camera" aria-hidden="true"></i>
        </button>
        <button style="color: white;background-color: transparent;border: 0px solid;" title="Export to csv" id="csv_export">
            <i class="fa fa-solid fa-file-csv"></i>
        </button>
        <button style="color: white;background-color: transparent;border: 0px solid;" id="full_screen_btn" class="mx-1"
            title="ChartView" onclick="optimizedFullScreenChart()">
            <i id="full_screen_icon" class="fa fa-solid fa-expand"></i>
        </button>
    </div>

    <!-- Performance optimized main application script -->
    <script type="text/javascript">
        'use strict';

        // Performance monitoring and optimization classes
        class PerformanceMonitor {
            constructor() {
                this.frameCount = 0;
                this.lastFrameTime = performance.now();
                this.fpsHistory = [];
                this.memoryUsage = [];
                this.enabled = true;
            }

            updateFrame() {
                if (!this.enabled) return;
                
                const now = performance.now();
                const fps = 1000 / (now - this.lastFrameTime);
                this.fpsHistory.push(fps);
                
                if (this.fpsHistory.length > 60) { // Keep last 60 frames
                    this.fpsHistory.shift();
                }
                
                // Monitor memory if available
                if (performance.memory) {
                    this.memoryUsage.push(performance.memory.usedJSHeapSize);
                    if (this.memoryUsage.length > 60) {
                        this.memoryUsage.shift();
                    }
                }
                
                // Performance warnings
                if (fps < 20) {
                    console.warn('Performance warning: FPS dropped to', fps.toFixed(2));
                    this.optimizePerformance();
                }
                
                this.lastFrameTime = now;
                this.frameCount++;
            }

            optimizePerformance() {
                // Reduce update frequency during low performance
                PERFORMANCE_CONFIG.UPDATE_THROTTLE_MS = Math.min(100, PERFORMANCE_CONFIG.UPDATE_THROTTLE_MS * 1.5);
                console.log('Performance optimization: Increased throttle to', PERFORMANCE_CONFIG.UPDATE_THROTTLE_MS, 'ms');
            }

            getAverageFPS() {
                if (this.fpsHistory.length === 0) return 0;
                return this.fpsHistory.reduce((a, b) => a + b) / this.fpsHistory.length;
            }

            disable() {
                this.enabled = false;
            }
        }

        // Optimized circular buffer with memory management
        class OptimizedCircularArray extends Array {
            constructor(maxLength) {
                super();
                this.maxLength = Math.min(maxLength, PERFORMANCE_CONFIG.MAX_CIRCULAR_BUFFER_SIZE);
                this._lastCleanup = Date.now();
                this._pool = []; // Object pool for reuse
            }

            push(element) {
                // Reuse objects from pool when possible
                if (typeof element === 'object' && this._pool.length > 0) {
                    const reused = this._pool.pop();
                    Object.assign(reused, element);
                    super.push(reused);
                } else {
                    super.push(element);
                }
                
                if (this.length > this.maxLength) {
                    const removed = this.splice(0, this.length - this.maxLength);
                    // Return objects to pool for reuse
                    removed.forEach(item => {
                        if (typeof item === 'object' && this._pool.length < 100) {
                            this._pool.push(item);
                        }
                    });
                }

                // Periodic cleanup
                const now = Date.now();
                if (now - this._lastCleanup > PERFORMANCE_CONFIG.CLEANUP_INTERVAL_MS) {
                    this._cleanup();
                    this._lastCleanup = now;
                }
            }

            _cleanup() {
                if (this.length > this.maxLength * 0.8) {
                    const elementsToRemove = Math.floor(this.length * 0.1);
                    const removed = this.splice(0, elementsToRemove);
                    removed.forEach(item => {
                        if (typeof item === 'object' && this._pool.length < 50) {
                            this._pool.push(item);
                        }
                    });
                }
            }

            clear() {
                this.length = 0;
                this._pool.length = 0;
            }

            destroy() {
                this.clear();
                this._pool = null;
            }
        }

        // Throttled update manager
        class UpdateThrottler {
            constructor(delay = PERFORMANCE_CONFIG.UPDATE_THROTTLE_MS) {
                this.delay = delay;
                this.lastUpdate = 0;
                this.pendingUpdate = null;
                this.queue = [];
            }

            throttle(func, priority = 0) {
                const now = performance.now();
                
                if (now - this.lastUpdate >= this.delay) {
                    this.executeImmediate(func);
                } else {
                    this.addToQueue(func, priority);
                }
            }

            executeImmediate(func) {
                try {
                    func();
                    this.lastUpdate = performance.now();
                } catch (error) {
                    console.error('Throttled function error:', error);
                }
            }

            addToQueue(func, priority) {
                this.queue.push({ func, priority, timestamp: performance.now() });
                this.queue.sort((a, b) => b.priority - a.priority);
                
                if (!this.pendingUpdate) {
                    this.pendingUpdate = setTimeout(() => {
                        this.processQueue();
                    }, this.delay - (performance.now() - this.lastUpdate));
                }
            }

            processQueue() {
                if (this.queue.length > 0) {
                    const item = this.queue.shift();
                    this.executeImmediate(item.func);
                }
                
                this.pendingUpdate = null;
                
                if (this.queue.length > 0) {
                    this.pendingUpdate = setTimeout(() => {
                        this.processQueue();
                    }, this.delay);
                }
            }

            clear() {
                if (this.pendingUpdate) {
                    clearTimeout(this.pendingUpdate);
                    this.pendingUpdate = null;
                }
                this.queue.length = 0;
            }
        }

        // Debounced function wrapper
        function debounce(func, delay) {
            let timeoutId;
            return function (...args) {
                clearTimeout(timeoutId);
                timeoutId = setTimeout(() => func.apply(this, args), delay);
            };
        }

        // Initialize performance monitoring
        const performanceMonitor = new PerformanceMonitor();
        const chartUpdateThrottler = new UpdateThrottler(PERFORMANCE_CONFIG.UPDATE_THROTTLE_MS);
        const markerUpdateThrottler = new UpdateThrottler(100);

        // Application state with performance tracking
        let appState = {
            // UI state
            full_screen_flag: false,
            button_click_max: false,
            button_click_min: false,
            button_click_avg: true,
            button_click_main: false,
            button_click_band: true,
            button_click_persistence: false,
            peak_data_flag: true,
            mark_data_flag: true,
            auto_Y_axis_flag: false,
            
            // Performance state
            isProcessing: false,
            lastDataUpdate: 0,
            framesBehind: 0,
            adaptiveQuality: true,
            
            // Counters
            counter: 0,
            freq_cnt: 0,
            time_counter: 0
        };

        // Configuration from server (cached)
        const config = {
            active_port: "{{active_port}}",
            active_channel: "{{active_channel}}",
            page_theme: "{{theme_mode}}",
            data: JSON.parse('{{ spectrum_data | tojson | safe}}')
        };

        // Optimized chart data management
        const chartData = {
            // Use Maps for better performance
            wxAxisBand: new Map(),
            xAxisBand: new Map(),
            band_center_freq: new Map(),
            wActualBand: new Map(),
            xActualBand: new Map(),
            bandLine: new Map(),
            wBandLine: new Map(),
            band_meta: new Map(),
            
            // Arrays for markers
            chartMarker: new Array(10),
            marker_label: new Array(10),
            addMarkerData: [],
            pos_x: [5],
            new_pos: [5],
            
            // Performance tracking
            dataPoints: 0,
            lastClear: Date.now()
        };

        // Optimized data processor with caching
        const dataProcessor = {
            _freqCache: new Map(),
            _sampleCache: new Map(),
            _lutCache: new Map(),

            calculateFrequencies() {
                const cacheKey = `${config.data.freq}_${config.data.start_frequency}_${config.data.stop_frequency}`;
                
                if (this._freqCache.has(cacheKey)) {
                    return this._freqCache.get(cacheKey);
                }

                const result = {
                    freq: config.data.freq / 1e6,
                    start_freq: config.data.start_frequency / 1e6,
                    stop_freq: config.data.stop_frequency / 1e6,
                    start_WF_freq: config.data.start_frequency / 1e6,
                    stop_WF_freq: config.data.stop_frequency / 1e6
                };

                this._freqCache.set(cacheKey, result);
                return result;
            },

            calculateSampleData() {
                const cacheKey = `${config.data.fft_points}_${config.data.bandwidth}_${config.data.sample_rate}`;
                
                if (this._sampleCache.has(cacheKey)) {
                    return this._sampleCache.get(cacheKey);
                }

                const sample_length = parseInt(config.data.fft_points);
                const actual_bw = config.data.bandwidth;
                const sample_rate = config.data.sample_rate;
                const diff = sample_rate - actual_bw;
                const cut_n = (sample_length * (diff / 2)) / sample_rate;
                const dataSampleSize = Math.floor(sample_length - (cut_n * 2));

                const result = {
                    sample_length,
                    actual_bw,
                    sample_rate,
                    diff,
                    cut_n,
                    dataSampleSize
                };

                this._sampleCache.set(cacheKey, result);
                return result;
            },

            clearCaches() {
                this._freqCache.clear();
                this._sampleCache.clear();
                this._lutCache.clear();
            }
        };

        // Calculate initial values
        const frequencies = dataProcessor.calculateFrequencies();
        const sampleData = dataProcessor.calculateSampleData();
        const { freq, start_freq, stop_freq, start_WF_freq, stop_WF_freq } = frequencies;
        const { sample_length, actual_bw, sample_rate, diff, cut_n, dataSampleSize } = sampleData;

        // Optimized function implementations
        const optimizedFullScreen = debounce(function() {
            appState.full_screen_flag = !appState.full_screen_flag;
            
            const elements = {
                fullScreenLabel: DOM_CACHE.get('full_screen_label'),
                tableCol: window.parent?.document?.getElementById("table_col"),
                closeBar: window.parent?.document?.getElementById("close-bar"),
                iframeCol: window.parent?.document?.getElementById("iframe_col")
            };
            
            if (appState.full_screen_flag) {
                elements.fullScreenLabel.innerHTML = `<i style='font-size:15px' class='fas fa-compress-arrows-alt'></i>`;
                if (elements.tableCol) elements.tableCol.style.display = "none";
                if (elements.closeBar) elements.closeBar.style.display = "none";
                if (elements.iframeCol) elements.iframeCol.className = "col-12";
            } else {
                elements.fullScreenLabel.innerHTML = `<i style='font-size:15px' class='fas fa-expand-arrows-alt'></i>`;
                if (elements.tableCol) elements.tableCol.style.display = "block";
                if (elements.closeBar) elements.closeBar.style.display = "block";
                if (elements.iframeCol) elements.iframeCol.className = "col-8";
            }
        }, PERFORMANCE_CONFIG.DEBOUNCE_DELAY_MS);

        const optimizedCollapseTrace = debounce(function(event) {
            const isDown = event === "dwn";
            const elements = {
                traceDown: DOM_CACHE.get('trace_dwn'),
                traceUp: DOM_CACHE.get('trace_up'),
                customLegend: DOM_CACHE.get('custom-legend'),
                tracemenu: DOM_CACHE.get('tracemenu'),
                outerTrace: DOM_CACHE.get('outer_trace')
            };
            
            requestAnimationFrame(() => {
                elements.traceDown.style.display = isDown ? "none" : "block";
                elements.traceUp.style.display = isDown ? "block" : "none";
                elements.customLegend.style.height = isDown ? "230px" : "40px";
                elements.tracemenu.style.display = isDown ? "block" : "none";
                if (elements.outerTrace) {
                    elements.outerTrace.style.paddingBottom = isDown ? "0px" : "5px";
                }
            });
        }, PERFORMANCE_CONFIG.DEBOUNCE_DELAY_MS);

        // Optimized websocket data handler
        function websocket_data(evt) {
            performanceMonitor.updateFrame();
            
            if (appState.isProcessing) {
                appState.framesBehind++;
                if (appState.framesBehind > 10) {
                    console.warn('Frames behind:', appState.framesBehind);
                    return; // Skip frame to catch up
                }
            }
            
            appState.isProcessing = true;
            
            chartUpdateThrottler.throttle(() => {
                try {
                    processWebSocketData(evt);
                } finally {
                    appState.isProcessing = false;
                    appState.framesBehind = Math.max(0, appState.framesBehind - 1);
                }
            }, 1); // High priority
        }

        function processWebSocketData(dataVal) {
            if (!dataVal || !dataVal.y || !Array.isArray(dataVal.y)) {
                return;
            }

            const now = performance.now();
            appState.lastDataUpdate = now;
            appState.freq_cnt = Math.min(appState.freq_cnt + 1, 5);

            // Adaptive quality based on performance
            if (appState.adaptiveQuality && performanceMonitor.getAverageFPS() < 25) {
                // Reduce data processing frequency during low performance
                if (appState.freq_cnt % 2 !== 0) return;
            }

            // Process main data
            if (window.caMaincurve) {
                window.caMaincurve.push(dataVal.y);
            }

            // Handle different message types
            if (dataVal.hasOwnProperty('message')) {
                handleMessage(dataVal);
            } else {
                processChartData(dataVal);
            }

            // Periodic cleanup
            if (now - chartData.lastClear > PERFORMANCE_CONFIG.CLEANUP_INTERVAL_MS) {
                cleanupChartData();
                chartData.lastClear = now;
            }
        }

        function handleMessage(dataVal) {
            switch (dataVal.message) {
                case "connect":
                    console.log("WebSocket connecting...");
                    break;
                case "connected":
                    console.log("WebSocket connected");
                    setTimeout(() => {
                        const loader = DOM_CACHE.get('websocket_loader');
                        if (loader) $('#websocket_loader').modal('hide');
                    }, 1000);
                    break;
            }
        }

        function processChartData(dataVal) {
            // Close loader on first data
            if (appState.freq_cnt === 1) {
                const loader = DOM_CACHE.get('websocket_loader');
                if (loader) $('#websocket_loader').modal('hide');
            }

            // Process traces with throttling
            processTraces(dataVal);
            processBands(dataVal);
            processMarkers(dataVal);
            processPeaks(dataVal);
        }

        function processTraces(dataVal) {
            if (appState.button_click_main && window.updateSeries) {
                chartUpdateThrottler.throttle(() => {
                    window.updateSeries(dataVal.x, dataVal.y);
                }, 2);
            }

            if (appState.button_click_avg && window.caAverage) {
                window.caAverage.push(dataVal.y);
                if (window.updateAvg && window.get_Average_data) {
                    chartUpdateThrottler.throttle(() => {
                        window.updateAvg(dataVal.x, window.get_Average_data());
                    }, 1);
                }
            }

            // Auto Y-axis adjustment
            if (appState.auto_Y_axis_flag && window.chart) {
                const minY = Math.min(...dataVal.y);
                const maxY = Math.max(...dataVal.y);
                chartUpdateThrottler.throttle(() => {
                    window.chart.getDefaultAxisY().setDefaultInterval({ start: minY, end: maxY });
                }, 3);
            }
        }

        function processBands(dataVal) {
            if (!appState.button_click_band) return;
            
            for (const [key, band] of chartData.xAxisBand) {
                if (band) {
                    const elements = [
                        chartData.xActualBand.get(key),
                        chartData.wActualBand.get(key),
                        chartData.xAxisBand.get(key),
                        chartData.wxAxisBand.get(key)
                    ];

                    chartUpdateThrottler.throttle(() => {
                        elements.forEach(element => {
                            if (element && element.setVisible) {
                                element.setVisible(true);
                            }
                        });
                    }, 3);
                }
            }
        }

        function processMarkers(dataVal) {
            if (!appState.mark_data_flag) return;

            markerUpdateThrottler.throttle(() => {
                for (let i = 0; i < chartData.chartMarker.length; i++) {
                    if (chartData.chartMarker[i] && window.update_marker) {
                        window.update_marker(i);
                    }
                }
            }, 2);
        }

        function processPeaks(dataVal) {
            if (!appState.peak_data_flag || !dataVal.auto_data) return;
            
            const peaks = Array.isArray(dataVal.auto_data) ? dataVal.auto_data : [];
            if (window.updateSeriespeak) {
                chartUpdateThrottler.throttle(() => {
                    window.updateSeriespeak(peaks);
                }, 2);
            }
        }

        function cleanupChartData() {
            // Clear old markers
            chartData.addMarkerData = chartData.addMarkerData.filter(marker => 
                marker && (Date.now() - marker.timestamp) < 30000
            );

            // Clear cached elements
            if (DOM_CACHE.elements.size > 50) {
                DOM_CACHE.clear();
            }

            // Force garbage collection if available
            if (window.gc) {
                window.gc();
            }

            console.log('Chart data cleanup completed');
        }

        // Optimized stub functions for backward compatibility
        const optimizedShowMainCurve = debounce(() => {
            appState.button_click_main = !appState.button_click_main;
            console.log('Main curve toggled:', appState.button_click_main);
        }, PERFORMANCE_CONFIG.DEBOUNCE_DELAY_MS);

        const optimizedShowTracesAvg = debounce(() => {
            appState.button_click_avg = !appState.button_click_avg;
            console.log('Average trace toggled:', appState.button_click_avg);
        }, PERFORMANCE_CONFIG.DEBOUNCE_DELAY_MS);

        const optimizedShowTracesMax = debounce(() => {
            appState.button_click_max = !appState.button_click_max;
            console.log('Max trace toggled:', appState.button_click_max);
        }, PERFORMANCE_CONFIG.DEBOUNCE_DELAY_MS);

        const optimizedShowTracesMin = debounce(() => {
            appState.button_click_min = !appState.button_click_min;
            console.log('Min trace toggled:', appState.button_click_min);
        }, PERFORMANCE_CONFIG.DEBOUNCE_DELAY_MS);

        const optimizedShowTracesPersis = debounce(() => {
            appState.button_click_persistence = !appState.button_click_persistence;
            console.log('Persistence trace toggled:', appState.button_click_persistence);
        }, PERFORMANCE_CONFIG.DEBOUNCE_DELAY_MS);

        const optimizedShowPeakData = debounce(() => {
            appState.peak_data_flag = !appState.peak_data_flag;
            console.log('Peak data toggled:', appState.peak_data_flag);
        }, PERFORMANCE_CONFIG.DEBOUNCE_DELAY_MS);

        const optimizedShowMarkData = debounce(() => {
            appState.mark_data_flag = !appState.mark_data_flag;
            console.log('Marker data toggled:', appState.mark_data_flag);
        }, PERFORMANCE_CONFIG.DEBOUNCE_DELAY_MS);

        const optimizedShowTracesBand = debounce(() => {
            appState.button_click_band = !appState.button_click_band;
            console.log('Band trace toggled:', appState.button_click_band);
        }, PERFORMANCE_CONFIG.DEBOUNCE_DELAY_MS);

        const optimizedFullScreenChart = debounce(() => {
            if (window.parent && window.parent.full_screen_chart) {
                window.parent.full_screen_chart();
            }
        }, PERFORMANCE_CONFIG.DEBOUNCE_DELAY_MS);

        // Initialize optimized circular arrays
        function initializeCircularArrays() {
            try {
                const avgLevel = window.parent?.document?.getElementById('avg_input')?.value || 5;
                const minLevel = window.parent?.document?.getElementById('min_hold_value')?.value || 5;
                const persistenceLevel = window.parent?.document?.getElementById('Persistence_hold_value')?.value || 5;

                window.caAverage = new OptimizedCircularArray(parseInt(avgLevel));
                window.caMin = new OptimizedCircularArray(parseInt(minLevel));
                window.caPersistence = new OptimizedCircularArray(parseInt(persistenceLevel));
                window.caMaincurve = new OptimizedCircularArray(5);

                console.log('Optimized circular arrays initialized');
            } catch (error) {
                console.error('Error initializing circular arrays:', error);
            }
        }

        // Initialize everything when DOM is ready
        document.addEventListener('DOMContentLoaded', () => {
            initializeCircularArrays();
            
            // Set up performance monitoring
            setInterval(() => {
                const avgFPS = performanceMonitor.getAverageFPS();
                if (avgFPS > 0 && avgFPS < 20) {
                    console.warn('Performance degraded. Average FPS:', avgFPS.toFixed(2));
                }
            }, 5000);

            // Set up screenshot handler
            const screenshotBtn = DOM_CACHE.get('screenshot_img');
            if (screenshotBtn) {
                screenshotBtn.onclick = debounce(() => {
                    if (window.chart) {
                        window.chart.saveToFile('Spectrum_screenshot');
                    }
                }, 1000);
            }

            // Set up CSV export handler
            const csvExportBtn = DOM_CACHE.get('csv_export');
            if (csvExportBtn) {
                csvExportBtn.onclick = debounce(() => {
                    if (window.export_csv_data) {
                        window.export_csv_data();
                    }
                }, 1000);
            }

            console.log('Optimized spectrum waterfall initialized');
        });

        // Memory cleanup on page unload
        window.addEventListener('beforeunload', () => {
            performanceMonitor.disable();
            chartUpdateThrottler.clear();
            markerUpdateThrottler.clear();
            
            if (window.caAverage) window.caAverage.destroy();
            if (window.caMin) window.caMin.destroy();
            if (window.caPersistence) window.caPersistence.destroy();
            if (window.caMaincurve) window.caMaincurve.destroy();

            dataProcessor.clearCaches();
            DOM_CACHE.clear();
            
            console.log('Memory cleanup completed');
        });

        // Export optimized functions for backward compatibility
        window.optimizedSpectrum = {
            appState,
            chartData,
            config,
            performanceMonitor,
            websocket_data,
            optimizedFullScreen,
            optimizedCollapseTrace,
            DOM_CACHE
        };

        console.log('Optimized real-time spectrum waterfall loaded successfully');
    </script>
</body>

{% endblock %}