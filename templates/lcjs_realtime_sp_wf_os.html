{% block content %}

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Spectrum and Water fall</title>
    <!-- <script src="https://cdn.jsdelivr.net/npm/@arction/lcjs@5.2.0/dist/lcjs.iife.js"></script> -->
    <script src="{{ url_for('static', filename='js/lcjs.iife.js')}}"></script>
    <link rel="stylesheet" type="text/css" href="{{ url_for('static', filename='css/bootstrap_4_lcjs.min.css')}}" />
    <script src="{{ url_for('static', filename='js/bootstrap.bundle_4_lcjs.min.js')}}"></script>
    <link rel="stylesheet" type="text/css" href="{{ url_for('static', filename='css/font-awsome-4.7.min.css')}}" />
    <link rel="stylesheet" type="text/css" href="{{ url_for('static', filename='css/openwebrx.css')}}" />
    <script src="{{ url_for('static', filename='lib/jquery/jquery.js')}}"></script>
    <script src="{{ url_for('static', filename='lib/popper.js/popper.js')}}"></script>
    <script src="{{ url_for('static', filename='lib/bootstrap/bootstrap.js')}}"></script>
    <script src="{{ url_for('static', filename='bootstrap/bootstrap.min.js')}}"></script>
    <script src="{{ url_for('static', filename='lib/perfect-scrollbar/js/perfect-scrollbar.jquery.js')}}"></script>
    <script src="{{ url_for('static', filename='lib/moment/moment.js')}}"></script>
    <script src="{{ url_for('static', filename='js/moment.min.js')}}"></script>
    <link rel="stylesheet" href="{{ url_for('static', filename='css/fontawesome.all.min.css')}}">
    <link rel="stylesheet" href="{{ url_for('static', filename='css/fontawesome.min.css')}}">
    <script src="{{ url_for('static', filename='js/fontawesome.all.min.js')}}"></script>
    <script src="{{ url_for('static', filename='js/fontawesome.min.js')}}"></script>
    <script src="{{ url_for('static', filename='lib/jquery-ui/jquery-ui.js')}}"></script>


    <style>

        #lcjs-auto-flexbox{
            background-color: transparent;
            }

        canvas{
            background-color: transparent;
            }
            
        body{
            background-color: transparent;
            }

        .full-screen-div {
            position: absolute;
            color: rgb(0, 0, 0);
            top: 38px;
            right: 29px;
            z-index: 1001;
            height: 25px;
            width: 25px;

        }

        .screen-shot-div {
            position: absolute;
            color: rgb(0, 0, 0);
            top: 38px;
            right: 42px;
            z-index: 1001;
            height: 25px;
            width: 25px;
        }

        #trace_dwn {

            position: absolute;

            top: 15px;
            right: 30px;
            z-index: 1001;


        }

        #trace_up {

            position: absolute;
            top: 15px;
            right: 30px;
            z-index: 1001;


        }

        #outer_trace {
            padding-top: 2px;
        }

        /* #tracemenu{
        padding: 5px 5px 0px 5px;  
        } */
        #custom-legend {
            background:rgb(0, 0, 0, 38%);
            padding: 10px;
            border: 1px solid #FFFFFF;
            /* border-radius: 5px; */
            color: white;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.2);
            position: absolute;
            top: 22px;
            right: 30px;
            z-index: 1000;
            height: 210px;
            width: 116px;
            transition:
                width 2s,
                height 2s,
                background-color 2s,
        }

        #custom_legend_camera {
            background: transparent;
            padding: 5px;
            border-radius: 5px;
            color: white;
            /* box-shadow: 0 0 10px rgba(0, 0, 0, 0.2); */
            position: absolute;
            left: 0px;
            bottom: 0px;
            z-index: 1000;
            height: auto;
            width: auto;
        }

        .legend-item {
            display: flex;
            align-items: center;
            margin-bottom: 5px;
            font-size: small;
        }

        .legend-checkbox {
            appearance: none;
            -webkit-appearance: none;
            -moz-appearance: none;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            border: 2px solid #ccc;
            outline: none;
            cursor: pointer;
            margin-right: 8px;
            position: relative;
        }

        .legend-checkbox:checked::after {
            content: "";
            display: block;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background-color: #d79c3c;
            position: absolute;
            /* top: 50%;
            left: 50%;
            transform: translate(-50%, -50%); */
        }
    </style>
</head>

<body>

    <div class="modal modal-backdrop fade" id="websocket_loader" tabindex="-1" role="dialog aria-labelledby="
        MultipleDeleteTargetModelLabel>
        <div class="modal-dialog modal-dialog-centered text-center " role="document">
            <div class="modal-body ">
                <!-- <div class="card" style="border: 1px solid var(--green-custom-color);"> -->
                <div class="m-0 px-0 py-5" style="background-color:white">
                    <i class="fa fa-spinner fa-spin fa-4x" style="color:black"></i>
                </div>
                <!-- </div> -->
            </div>
        </div>
    </div>


    <div class="full-screen-div ml-1">
        <div class="">
            <label for="full_screen" class="full_screen uil uil-expand-arrows-alt" id="full_screen_label"
                style="color: #ffffff; cursor: pointer;" onclick="full_screen()"><i style='font-size:15px'
                    data-bs-toggle="tooltip" data-bs-placement="left" title="Full Screen"
                    class='fas fa-expand-arrows-alt'></i></label>
        </div>
    </div>

    <div id="custom-legend">
        <div id="outer_trace">
            <label for="" id="traces_label">Traces</label>

            <i class="fa fa-caret-down" id="trace_dwn" style="display: block;" onclick="collapse_trace('dwn')"></i>
            <i class="fa fa-caret-up" id="trace_up" style="display:none ;" onclick="collapse_trace('up')"></i>

            <div id="tracemenu" style="display:none ;">
                <div class="legend-item">
                    <input type="checkbox" class="legend-checkbox" id="main_curve" checked onclick="show_main_curve()">
                    <label for="main_curve" class="main_curve" id="main_curve_label">Main-Curve</label>
                </div>
                <div class="legend-item">
                    <input type="checkbox" class="legend-checkbox" id="max_hold" onclick="show_traces_max()">
                    <label for="max_hold" class="max_hold" style="color: red;">Max-Hold</label>
                </div>
                <div class="legend-item">
                    <input type="checkbox" class="legend-checkbox" id="min_hold" onclick="show_traces_min()">
                    <label for="min_hold" class="min_hold" style="color: #37a6de">Min-Hold</label>
                </div>
                <div class="legend-item">
                    <input type="checkbox" class="legend-checkbox" id="avg_hold" onclick="show_traces_avg()">
                    <label for="avg_hold" class="avg_hold" style="color: green;">Avg-hold</label>
                </div>
                <div class="legend-item">
                    <input type="checkbox" class="legend-checkbox" id="peak_data_btn" checked
                        onclick="show_peak_data()">
                    <label for="peak_data_btn" class="peak_data_btn" style="color: rgb(235, 48, 41);">Peaks</label>
                </div>
                <div class="legend-item">
                    <input type="checkbox" class="legend-checkbox" id="mark_data_btn" checked
                        onclick="show_mark_data()">
                    <label for="mark_data_btn" id="marker_color_label" class="mark_data_btn"
                        style="color:#d7d6db">Markers</label>
                </div>
            </div>
        </div>
    </div>

    <div id="custom_legend_camera">
        <button style="color: white;background-color: transparent;border: 0px solid;" title="Screenshot"
            id="screenshot_img"><i class="fa fa-camera" aria-hidden="true"></i>
        </button>
        <button style="color: white;background-color: transparent;border: 0px solid;" title="Export to csv"
            id="csv_export"><i class="fa fa-solid fa-file-csv"></i>
        </button>
        <button style="color: white;background-color: transparent;border: 0px solid;" id="full_screen_btn" class="mx-1"
            title="ChartView" onclick="window.parent.full_screen_chart()"><i id="full_screen_icon"
                class="fa fa-solid fa-expand"></i>
        </button>
    </div>


    <script type="text/javascript">

        var button_click_max = false
        var button_click_min = false
        var button_click_avg = false
        var button_click_main = true

        var wxAxisBand = {};
        var xAxisBand = {};

        var constantLine1 = {}
        var constantLine2 = {}
        var auto_threshold_flag = false
        var auto_Y_axis_flag = false
        var peak_data_flag = true
        var mark_data_flag = true

        const minBandSize = 100000;
        const maxBandSize = 200000;

        var clicks = 0;
        var addMarkerData = new Array();

        var active_port = "{{active_port}}";
        var peak_port = "{{peak_port}}"
        var page_theme = "{{theme_mode}}"

        var active_channel = "{{active_channel}}";
        var active_mode= "{{active_mode}}";
        var data = JSON.parse('{{ spectrum_data | tojson | safe}}');
        var full_screen_flag = false

        var type_of_mode = {
            "fm": "audio",
            "wfm": "audio",
            "drm": "audio",
            "am": "audio",
            "lsb": "audio",
            "usb": "audio",
            'dmr': "data",
            'dstar': "audio",
            'nxdn': "audio",
            'ysf': "audio",
            'm17': "audio",
            'nbfm': "audio"
        }

        var unit_conversion = {
            "khz": 1e3,
            "mhz": 1e6,
            "ghz": 1e9
        }

        var freq = data['freq'] / 1e6
        var start_freq = data['start_frequency'] / 1e6
        var stop_freq = data['stop_frequency'] / 1e6
        var start_WF_freq = data['start_frequency'] / 1e6
        var stop_WF_freq = data['stop_frequency'] / 1e6
        var sample_length = parseInt(data['fft_points'])
        var sample_points = data['sample_points']

        var dataSampleSize = sample_length
        var sampleRateHz = 100
        var heatmapMinTimeStepMs = 1  // 1 millisecond

        let viewMs = 100;
        var time_counter = 0 // change in value also dosent affect anything                      
        var waterFall;
        var chart;
        var marker_color, theme_color, threshold_color;
        var freqDict = [];
        Max_cycles = 5;
        avg_max_cycle = 30

        let cycleData = [];
        // let minValues;
        // let maxValues;
        // let avgValues;
        let dataSampleSize_1 = sample_length;
        var dataVal;
        let tPrev = 1
        var chartMarker = [];
        var counter = 0
        var local_store, pos_x = [5], new_pos = [5]
        let rightMbPress


        window.parent.document.addEventListener('fullscreenchange', exitHandler);
        window.parent.document.addEventListener('webkitfullscreenchange', exitHandler);
        window.parent.document.addEventListener('mozfullscreenchange', exitHandler);
        window.parent.document.addEventListener('MSFullscreenChange', exitHandler);

        function exitHandler() {
            if (!window.parent.document.fullscreenElement && !window.parent.document.webkitIsFullScreen && !window.parent.document.mozFullScreen && !window.parent.document.msFullscreenElement) {
                if (!parent.table_full) {
                    document.getElementById('full_screen_icon').classList.remove('fa-compress')
                    document.getElementById('full_screen_icon').classList.add('fa-expand')
                    parent.full_iframe = false;
                }

            }
            else {
                if (!parent.table_full) {
                    document.getElementById('full_screen_icon').classList.remove('fa-expand')
                    document.getElementById('full_screen_icon').classList.add('fa-compress')
                    parent.full_iframe = true;
                }
            }
        }


        function collapse_trace(event) {
            if (event == "dwn") {
                document.getElementById("trace_dwn").style.display = "none"
                document.getElementById("trace_up").style.display = "block"
                document.getElementById("custom-legend").style.height = "195px"
                document.getElementById("tracemenu").style.display = "block"
            } else {
                document.getElementById("trace_dwn").style.display = "block"
                document.getElementById("trace_up").style.display = "none"
                document.getElementById("custom-legend").style.height = "40px"
                document.getElementById("tracemenu").style.display = "none"

            }
        }


        try {
            var wf_speed = window.parent.document.getElementById('waterfall_speed').value;

            if (wf_speed === 'fast') {
                viewMs = 100;
            } else if (wf_speed === 'medium') {
                viewMs = 1024;
            } else if (wf_speed === 'slow') {
                viewMs = 2048;
            } else {
                viewMs = 100;
            }
        }
        catch (error) {
            viewMs = 100;
        }
        // =================== lc js import ====================
        const {
            lightningChart, DashedLine, emptyFill, individualPointColorEnabled, PointShape, PalettedFill, LUT, ColorHSV, emptyLine, AxisScrollStrategies, AxisTickStrategies, SolidFill, Themes,
            LegendBoxBuilders, UIElementBuilders, UIOrigins, AutoCursorModes, UIVisibilityModes, UIDraggingModes, SolidLine, tickStrategy,
            regularColorSteps, synchronizeAxisIntervals, Axis, onMouseDoubleClick, ColorRGBA, setLabel, removeMarker, ColorHEX
        } = lcjs;


         


        // ==================== dashboard ========================= Dashboard to divide into waterfall and spectrum 


        if (page_theme == 'dark') {
            const dashboard = lcc.Dashboard({
                numberOfColumns: 1,
                numberOfRows: 3,
                // theme: Themes.light,//extra themes for dashboard
            })
            waterFall = dashboard.createChartXY({
                rowIndex: 2,
                columnIndex: 0,
                container: 'waterFallContainer',
                // Width: 70
            })

            chart = dashboard.createChartXY({
                container: 'chartContainer',// Specify the container element
                rowIndex: 1,
                columnIndex: 0,
            });
            chartWaveform = dashboard.createChartXY({
                // container: 'chartContainer',
                columnIndex: 0,
                rowIndex: 0,

            }).setMouseInteractions(true)
                .setTitle(false)
            // .setPadding(10)
        }
        else {
            const dashboard = lcc.Dashboard({
                numberOfColumns: 1,
                numberOfRows: 3,
                theme: Themes.light,//extra themes for dashboard
            })
            waterFall = dashboard.createChartXY({
                rowIndex: 2,
                columnIndex: 0,
                container: 'waterFallContainer',
                // Width: 70
            })

            chart = dashboard.createChartXY({
                container: 'chartContainer',// Specify the container element
                rowIndex: 1,
                columnIndex: 0,
            });
            chartWaveform = dashboard.createChartXY({
                // container: 'chartContainer',
                columnIndex: 0,
                rowIndex: 0,

            }).setTitle('Oscillioscope')
                .setMouseInteractions(true)
            // .setPadding(10)

        }


        // ==================== waterfall Axis FUNCTIONS in dashboard =========================
        
        // ==================== waterfall Axis FUNCTIONS in dashboard =========================
        function waterfall_XYAxis() {

        waterFall.setTitle(false)
            .getDefaultAxisY()
            .setTitle('Time')
            .setScrollStrategy(AxisScrollStrategies.progressive)
            .setTickStrategy(AxisTickStrategies.Time, tickStrategy => tickStrategy
                .setTickStyle(ticks => ticks
                    .setLabelFont(font => font.setSize(12))
                    .setTickStyle(emptyLine)
                )
            )

        waterFall.getDefaultAxisX().setTitle('Frequency (Hz)').setInterval({ start: start_freq, end: stop_freq })
        //disable cursor
        waterFall.setAutoCursorMode(AutoCursorModes.disabled)
            .setMouseInteractionRectangleFit(true)

        try {
            var wf_speed = window.parent.document.getElementById('waterfall_speed').value;

            if (wf_speed === 'fast') {
                viewMs = 100;
            } else if (wf_speed === 'medium') {
                viewMs = 1024;
            } else if (wf_speed === 'slow') {
                viewMs = 2048;
            } else {
                viewMs = 100;
            }
            waterFall.getDefaultAxisY().setDefaultInterval((state) => ({ end: state.dataMax, start: (state.dataMax ?? 0) - viewMs, stopAxisAfter: false }))
        }
        catch (error) {
            viewMs = 100;
        }

        waterFall.getDefaultAxisY().setDefaultInterval((state) => ({ end: state.dataMax, start: (state.dataMax ?? 0) - viewMs, stopAxisAfter: false }))
        }


        // ==================== waterfall COLOR constants in dashboard =========================

        const theme = waterFall.getTheme()
        var lut = new LUT({
            // steps: regularColorSteps(-40, -150, theme.examples.),
            steps: [
                { value: -20, color: ColorRGBA(255, 250, 205) },//green
                { value: -70, color: ColorRGBA(2, 0, 185) },//red
                { value: -150, color: ColorRGBA(173, 216, 230) },//green


            ],
            units: 'dBm',
            interpolate: true,
        })
        var paletteFill = new PalettedFill({ lut, lookUpProperty: 'value' })


        // ==================== ======================================= =========================


        // ==============================================Create Scrolling Heatmap Grid Series ============================


        const heatmapSeries = waterFall
            .addHeatmapScrollingGridSeries({

                scrollDimension: 'rows',
                resolution: dataSampleSize,

                start: { x: start_freq, y: 0 },
                step: { x: (stop_freq - start_freq) / sample_length, y: heatmapMinTimeStepMs },

            })
            .setFillStyle(paletteFill)
            .setWireframeStyle(emptyLine)
            .setName('Waterfall')

            // Configure automatic data cleaning.
            .setDataCleaning({
                // Out of view data can be lazily removed as long as total columns count remains over 1000.
                minDataPointCount: 10,
            })


        function load_setting_data() {
            var json_data = {
                "mode": "realtime",
                "channel": active_channel
            }

            $.ajax({
                type: 'POST',
                url: '/get_reflevel_amp',
                data: JSON.stringify(json_data),
                contentType: 'application/json',
                success: function (data) {

                    waterFall.getDefaultAxisX().setInterval({ start: parseInt(data['start_frequency']) / 1e6, end: parseInt(data['stop_frequency']) / 1e6, stopAxisAfter: true })

                    heatmapSeries.setStart({ x: parseInt(data['start_frequency']) / 1e6, y: -120 }) //.setStep({ x: heatmapMinTimeStepMs, y: 1 })


                    // addBand(fre_val, 100, data[data.length - 1]['name'], data[data.length - 1]['uid'],data[data.length - 1]['color'])
                    // parent.get_demodulators_for_active_channel()
                    // plot_all_demods()
                    // series.clear()
                    //
                    heatmapSeries.clear()
                    // iq_data()
                }
            });
        }


        const handleIncomingData = (timestamp, sample) => {
            // Calculate sample index from timestamp to place sample in correct location in heatmap.
            const iSample = Math.round(timestamp / heatmapMinTimeStepMs)
            heatmapSeries.invalidateIntensityValues({
                iSample,
                values: [sample],
            })
        }


        // Enable automatic cleaning of data that is not visible
        heatmapSeries.setDataCleaning({ minDataPointCount: 1 })
        // ======================================= ==========End Waterfall ===================================================


        const seriesWaveform = chartWaveform
            .addPointLineAreaSeries({
                dataPattern: 'ProgressiveX',
                allowInputModification: false,
            })
            .setStrokeStyle((stroke) => stroke.setThickness(-1))
            .setMaxSampleCount(1000000)
            .setPointFillStyle(emptyFill)
            .setAreaFillStyle(emptyFill)
            .setCursorEnabled(false)

        chartWaveform
            .getDefaultAxisX()
            .setScrollStrategy(AxisScrollStrategies.progressive)
            .setTickStrategy(AxisTickStrategies.Time)
            .setDefaultInterval((state) => ({
                start: (state.dataMax ?? 0),
                end: state.dataMax,
                stopAxisAfter: false,
            }))
            .fit(false)


        chartWaveform.getDefaultAxisY().setAnimationScroll(true).setChartInteractionZoomByWheel(true).setTitle('Oscillioscope')
        // chartWaveform.getDefaultAxisY().setTickStrategy(AxisTickStrategies.Empty)
        chartWaveform.getDefaultAxisX().setTickStrategy(AxisTickStrategies.Time)
        // chartWaveform.setChartInteractionZoomByWheel(true)


        //  ========================= spectrum ===========================

        const maxSeries = chart.addPointLineAreaSeries({sizes:true}).setName('Max Hold').setStrokeStyle((stroke) => stroke.setThickness(-1)).setPointSize(0).setPointFillStyle(new SolidFill({ color: ColorRGBA(255, 0, 0) })).setAreaFillStyle(new SolidFill({ color: ColorRGBA(60, 0, 0) }))
        const series = chart.addLineSeries().setStrokeStyle((stroke) => stroke.setThickness(-1));
        const minSeries = chart.addLineSeries().setName('Min Hold').setStrokeStyle((stroke) => stroke.setThickness(-1));
        const avgSeries = chart.addLineSeries().setName('Avg Hold').setStrokeStyle((stroke) => stroke.setThickness(2));
        const seriespeak = chart.addPointSeries({ pointShape: PointShape.Circle }).setPointSize(12).setAutoScrollingEnabled(false)


        function get_spectrum_setting(active_channel) {
            json = { "channel": active_channel, "mode": "realtime" }
            $.ajax({
                type: 'POST',
                url: '/get_realtime_setting',
                data: JSON.stringify(json),
                contentType: 'application/json',
                success: function (data1) {


                }
            })



        }


        // Customize the chart appearance
        chart.setTitle(false);
        // chart.getDefaultAxisX().setInterval({ start: start_freq, end: stop_freq });

        // chart.getDefaultAxisY().setTitle('Amplitude (dBm)').setInterval({ start: -140, end: -20 }).setDefaultInterval({ start: -140, end: -20 })
        chart.getDefaultAxisY().setTitle('Amplitude (dBm)')
        chart.getDefaultAxisX().setAxisInteractionReleaseByDoubleClicking(false) //.setInterval({ start: 138.2, end: 147.8, stopAxisAfter: true })
        chart.setMouseInteractionWheelZoom(true)


        // Function to generate data from arrays

        function generateData(xArray, yArray) {

            return xArray.map((x, i) => ({ x: xArray[i] / 1e6, y: yArray[i] }));
        }


        function generateDatapeak(xArray, yArray) {

            return xArray.map((x, i) => ({ x: xArray[i] / 1e6, y: yArray[i] }));
        }


        // Function to update the series with new data
        function updateSeries(xArray, yArray) {
            series.clear();
            series.add(generateData(xArray, yArray));
        }


        function updateMin(xArray, yArray) {
            minSeries.clear();
            minSeries.add(generateData(xArray, yArray));

        }


        function updateMax(xArray, yArray) {
            maxSeries.clear();
            maxSeries.add(generateData(xArray, yArray));
        }

        
        function updateAvg(xArray, yArray) {
            avgSeries.clear();
            avgSeries.add(generateData(xArray, yArray));
        }


        function updateSeriespeak(data) {
            seriespeak.clear();
            seriespeak.add(data);
        }

        //  colour adding to series (spectrum)

        const fillRed = new SolidFill({ color: ColorRGBA(255, 0, 0, 255) })
        const fillYellow = new SolidFill({ color: ColorHEX('#FFFF00') })
        const fillBlue = new SolidFill({ color: ColorHEX('#37a6de') })
        const fillGreen = new SolidFill({ color: ColorHEX('#008000') })
        const fillNavyBlue = new SolidFill({ color: ColorHEX('#00008B') })
        const fillQSRGreen = new SolidFill({ color: ColorHEX('#66cc35') })

         maxSeries.setAreaFillStyle(new SolidFill({ color: ColorRGBA(60, 0, 0,100) }))
        if (page_theme == 'light') {
            series.setStrokeStyle((stroke) => stroke.setFillStyle(fillNavyBlue))

            chart
                .setBackgroundFillStyle(new SolidFill({ color: ColorHEX('#F5F5F5') }))
                .setSeriesBackgroundFillStyle(new SolidFill({ color: ColorHEX('#F5F5F5') }))
                .setSeriesBackgroundStrokeStyle(new SolidLine({ thickness: 2, fillStyle: new SolidFill({ color: ColorRGBA(255, 255, 255) }) }))
            chart.getDefaultAxisY().setTitle('Amplitude (dBm)').setTickStrategy(AxisTickStrategies.Numeric, tickStrategy => tickStrategy
                .setTickStyle(ticks => ticks.setGridStrokeStyle((new SolidLine({ thickness: 1, fillStyle: new SolidFill({ color: ColorRGBA(128, 128, 128) }) })))

                )
            )
            chart.getDefaultAxisX().setAxisInteractionReleaseByDoubleClicking(false).setTickStrategy(AxisTickStrategies.Numeric, tickStrategy => tickStrategy
                .setTickStyle(ticks => ticks.setGridStrokeStyle((new SolidLine({ thickness: 1, fillStyle: new SolidFill({ color: ColorRGBA(128, 128, 128) }) })))
                )
            )

            waterFall
                .setBackgroundFillStyle(new SolidFill({ color: ColorHEX('#F5F5F5') }))
                .setSeriesBackgroundFillStyle(new SolidFill({ color: ColorHEX('#F5F5F5') }))
                .setSeriesBackgroundStrokeStyle(new SolidLine({ thickness: 2, fillStyle: new SolidFill({ color: ColorRGBA(255, 255, 255) }) }))
            waterFall.getDefaultAxisY().setTitle('Amplitude (dBm)').setTickStrategy(AxisTickStrategies.Numeric, tickStrategy => tickStrategy
                .setTickStyle(ticks => ticks.setGridStrokeStyle((new SolidLine({ thickness: 1, fillStyle: new SolidFill({ color: ColorRGBA(128, 128, 128) }) })))

                )
            )
            waterFall.getDefaultAxisX().setAxisInteractionReleaseByDoubleClicking(false).setTickStrategy(AxisTickStrategies.Numeric, tickStrategy => tickStrategy
                .setTickStyle(ticks => ticks.setGridStrokeStyle((new SolidLine({ thickness: 1, fillStyle: new SolidFill({ color: ColorRGBA(128, 128, 128) }) })))
                )
            )

            marker_color = '#FF13F0'
            theme_color = "#000000"
            threshold_color = '#000000'

            document.getElementById('main_curve_label').style.color = '#0827F5'
            document.getElementById('trace_dwn').style.color = '#4B5320'
            document.getElementById('trace_up').style.color = '#4B5320'
            document.getElementById('traces_label').style.color = '#4B5320'
            document.getElementById('custom-legend').style.background = '#ffffffcf'
            document.getElementById('full_screen_label').style.color = '#4B5320'
            document.getElementById('screenshot_img').style.color = '#4B5320'
            document.getElementById('csv_export').style.color = '#4B5320'
            document.getElementById('full_screen_btn').style.color = '#4B5320'
        }
        else {
            series.setStrokeStyle((stroke) => stroke.setFillStyle(fillYellow))
            marker_color = '#FF13F0'
            theme_color = '#808080'
            threshold_color = '#FFFFFF'

            document.getElementById('main_curve_label').style.color = '#FFFF00'
            document.getElementById('trace_dwn').style.color = threshold_color
            document.getElementById('trace_up').style.color = threshold_color
            document.getElementById('traces_label').style.color = threshold_color
            document.getElementById('full_screen_label').style.color = threshold_color

        }


        if (page_theme == 'light') {
            seriesWaveform.setStrokeStyle((stroke) => stroke.setFillStyle(fillNavyBlue))
            // document.getElementById('full_screen_img').style.color = 'black'
        }
        else {
            seriesWaveform.setStrokeStyle((stroke) => stroke.setFillStyle(fillYellow))
        }

        document.getElementById("marker_color_label").style.color = marker_color

        maxSeries.setStrokeStyle((stroke) => stroke.setFillStyle(fillRed))
        minSeries.setStrokeStyle((stroke) => stroke.setFillStyle(fillBlue))
        avgSeries.setStrokeStyle((stroke) => stroke.setFillStyle(fillGreen))
        seriespeak.setPointFillStyle(fillQSRGreen)

        function get_bookmark_data_clear() {
            document.getElementById('openwebrx-dialog-bookmark').style.display = "none";
        }

        chart.setPadding({ left: 20 })
        chartWaveform.setPadding({ left: 25 })


        //=========================================== synchronize Axis ======================================================
        
        synchronizeAxisIntervals(waterFall.getDefaultAxisX(), chart.getDefaultAxisX());
        // synchronizeAxisIntervals(waterFall.getDefaultAxisY(), chart.getDefaultAxisX());


        function hexToRgb(hex) {
            var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? {
                r: parseInt(result[1], 16),
                g: parseInt(result[2], 16),
                b: parseInt(result[3], 16)
            } : null;

        }


        // =============================================== Add Markar =================================================


        var min_step_avg;
        function reconfig_lut(){
            // console.log("Start",dataVal.y.length)
            array = dataVal.y
            var total = 0
            for(var i = 0; i < dataVal.y.length; i++) {
                total += dataVal.y[i];
            }
            var avg = total / dataVal.y.length;
            min_step_avg = parseInt(dataVal.y.reduce((a, b) => a + b) / dataVal.y.length);
            mid_step_avg = min_step_avg + 10
            max_step_avg = min_step_avg + 20
            console.log("Start",avg,min_step_avg)
            if(((parent.document.getElementById('waterfall_theme').value).slice(0,-2)) == "preset"){
                // console.log("preset")
                lut = new LUT({
                    // steps: regularColorSteps(-20, -120, theme.examples.spectrogramColorPalette),
                    steps: [
                        // { value: 0 , color: ColorHEX("#00000000") },//green
                        { value: parseInt(parent.document.getElementById('min_step_theme').value), color: ColorHEX(parent.document.getElementById("b_color3").value) },//green
                        { value: parseInt(parent.document.getElementById('mid_step_theme').value), color: ColorHEX(parent.document.getElementById("b_color2").value) },//red
                        { value: parseInt(parent.document.getElementById('max_step_theme').value), color: ColorHEX(parent.document.getElementById("b_color1").value) },//green
                    ],
                    units: 'dBm',
                    interpolate: true,
                })
            }
            else if(parent.document.getElementById('waterfall_theme').value == "theme_1" || parent.document.getElementById('waterfall_theme').value == "theme_3"){
                lut = new LUT({
                    // steps: regularColorSteps(-20, -120, theme.examples.spectrogramColorPalette),
                    steps: [
                        // { value: 0, color: ColorHEX("#00000000") },
                        { value: min_step_avg + 25, color: ColorHEX(parent.max_step) },
                        { value: min_step_avg + 15, color: ColorHEX(parent.mid_step1) },
                        { value: min_step_avg + 10 , color: ColorHEX(parent.mid_step2) },
                        { value: min_step_avg , color: ColorHEX(parent.min_step) },
                    ],
                    units: 'dBm',
                    interpolate: true,
                })
            }
           else if(parent.document.getElementById('waterfall_theme').value == "theme_2"){

                lut = new LUT({
                    // steps: regularColorSteps(-20, -120, theme.examples.spectrogramColorPalette),
                    steps: [
                        // { value: 0, color: ColorHEX("#00000000") },//blue
                        { value: max_step_avg, color: ColorHEX(parent.max_step) },//green
                        { value: mid_step_avg, color: ColorHEX(parent.mid_step1) },//red
                        { value: min_step_avg, color: ColorHEX(parent.min_step) },//green
                    ],
                    units: 'dBm',
                    interpolate: true,
                })
            }
            else {

                lut = new LUT({
                    // steps: regularColorSteps(-20, -120, theme.examples.spectrogramColorPalette),
                    steps: [
                        // { value: 0, color: ColorHEX("#00000000") },//blue
                        { value: parseInt(parent.max_step_val), color: ColorHEX(parent.max_step) },//green
                        { value: parseInt(parent.mid_step_val), color: ColorHEX(parent.mid_step1) },//red
                        { value: parseInt(parent.min_step_val), color: ColorHEX(parent.min_step) },//green
                    ],
                    units: 'dBm',
                    interpolate: true,
                })
            }
            
            paletteFill = new PalettedFill({ lut, lookUpProperty: 'value' })
            heatmapSeries
            .setFillStyle(paletteFill)

            if(legend2){
                legend2.dispose()
            }
            legend2 = waterFall
                .addLegendBox(legendBuilder)
                .setTitle(false)
                .setPosition({ x: 97.5, y: 95.5 })

            legend2.setBackground((background) => background
                .setFillStyle(new SolidFill({ color: ColorHEX(legend_backgrd) }))
                .setStrokeStyle(new SolidLine({ thickness: 1, fillStyle: new SolidFill({ color: ColorHEX('#FFFFFF') }) }))
            )
            legend2.add(heatmapSeries, { toggleVisibilityOnClick: false })
            legend2.setDraggingMode(0)
            // console.log("End")
            
        }

       
       
        function addMarkar() {
            const xnum = Number(document.getElementById('xnum').value)
            const ynum = Number(document.getElementById('ynum').value)
            const mname = document.getElementById('mname').value
            const chartMarker = chart.addChartMarkerXY().setPosition({ x: xnum, y: ynum })
            chartMarker
                .setResultTableVisibility(UIVisibilityModes.always)
                .setResultTable((table) => table.setContent([[mname]]))
                .setGridStrokeXVisibility(UIVisibilityModes.whenDragged)
                .setGridStrokeYVisibility(UIVisibilityModes.whenDragged)
                .setTickMarkerXVisibility(UIVisibilityModes.whenDragged)
                .setTickMarkerYVisibility(UIVisibilityModes.whenDragged)
                .setGridStrokeXStyle(new SolidLine({ fillStyle: new SolidFill({ color: ColorHEX("#FFF000"), thickness: 10 }) }));
        }


        chart.onSeriesBackgroundMouseDoubleClick((_, event) => {
            const locationAxis = chart.translateCoordinate(event, chart.coordsAxis)
            document.getElementById("frequency").value = (locationAxis.x / 1e6).toFixed(3);
            document.getElementById("name").value = document.getElementById("modulation").value
            document.getElementById("unit").value = "mhz"
            document.getElementById("b_color").value = getRandomColor()
            document.getElementById('openwebrx-dialog-bookmark').style.display = "block";
            // get_bookmark_data()
        })


        series.onMouseDoubleClick((_, event) => {
            const locationAxis = chart.translateCoordinate(event, chart.coordsAxis)
            document.getElementById("frequency").value = (locationAxis.x / 1e6).toFixed(3);
            document.getElementById("name").value = document.getElementById("modulation").value
            document.getElementById("unit").value = "mhz"
            document.getElementById('openwebrx-dialog-bookmark').style.display = "block";
        })


        function set_min_max_amp(min, max) {
            // chart.setInterval
            chart.getDefaultAxisY().setInterval({ start: min, end: max }).setDefaultInterval({ start: min, end: max })
        }


        function generateRGBFromRange(min, max) {
            // Function to generate a random number within the range [min, max]
            const getRandomInRange = (min, max) => Math.round(min + Math.random() * (max - min));
            // Generate RGB values
            return {
                r: getRandomInRange(min, max),
                g: getRandomInRange(min, max),
                b: getRandomInRange(min, max),
            };
        }


        function set_min_max_amp_wf(min, max) {
            rgbval = generateRGBFromRange(min, max)
        }


        const yAxis = chart.getDefaultAxisY()

        const threshold = yAxis.addConstantLine()
        threshold.setStrokeStyle(new SolidLine({
            thickness: 1,
            fillStyle: new SolidFill({ color: ColorHEX(threshold_color) })
        }))



        const threshold1 = yAxis
        .addCustomTick(UIElementBuilders.PointableTextBox)
        .setMouseInteractions(true)
        // .setAllocatesAxisSpace(true)
        .setTickLabelPadding(1)
        .setTextFormatter(
          (value) => "Threshold"
        );
        threshold1.setGridStrokeStyle(
            new SolidLine({
                thickness: 0,
                fillStyle: new SolidFill({ color: ColorHEX(threshold_color) }),
                // pattern: StipplePatterns.Dashed,
                patternScale: 4,
            }),
        )

        threshold.onMouseDrag((_,event) => {
            const locationAxis = chart.translateCoordinate(event,chart.coordsAxis)
            const displayTimeNew = locationAxis.y;
            threshold1.setValue(threshold.getValue())
            parent.document.getElementById('threshold').value = threshold.getValue().toFixed(0)
        })
        threshold1.getMarker().onMouseDrag((_,event) => {
            const locationAxis = chart.translateCoordinate(event,chart.coordsAxis)
            const displayTimeNew = locationAxis.y;
            threshold1.setValue(parseInt(displayTimeNew))
            threshold.setValue(parseInt(displayTimeNew))
            parent.document.getElementById('threshold').value = threshold.getValue().toFixed(0)
        })

        function set_threshold1(upd_threshold) {
            // threshold.dispose()
            threshold.setValue(upd_threshold)
            threshold1.setValue(upd_threshold)
            window.parent.document.getElementById('threshold').value = (upd_threshold)
            const yPalette = new PalettedFill({
                lookUpProperty: 'y',
                lut: new LUT({
                    interpolate: false,
                    steps: [
                        { value: -20, color: ColorRGBA(60, 179, 113) },//green
                        { value: Math.round(upd_threshold ), color: ColorRGBA(255, 69, 0) },//red
                        { value: -150, color: ColorHEX('#FFFF00') },//green
                    ],
                }),
            })
            // ele = window.parent.document.getElementById('threshold')
            // parent.get_all_data(ele)
        }


        ele = window.parent.document.getElementById('threshold')
        parent.get_all_data(ele)


        threshold.onMouseDragStop((_, event, Value) => {

            window.parent.document.getElementById('threshold').value = parseInt(threshold.getValue())
            parent.set_threshold(parseInt(threshold.getValue()))
            window.parent.update_parameters({ 'threshold': parseInt(threshold.getValue()) })
        })
        
        threshold1.getMarker().onMouseDragStop((_, event, Value) => {

            window.parent.document.getElementById('threshold').value = parseInt(threshold.getValue())
            parent.set_threshold(parseInt(threshold.getValue()))
            window.parent.update_parameters({ 'threshold': parseInt(threshold.getValue()) })
        })  
        const yPalette = new PalettedFill({
            lookUpProperty: 'y',
            lut: new LUT({
                interpolate: false,
                steps: [
                    { value: -20, color: ColorRGBA(60, 179, 113) },//green
                    { value: Math.round(threshold.getValue()), color: ColorRGBA(255, 69, 0) },//red
                    { value: -150, color: ColorHEX('#FFFF00') },//green
                ],
            }),
        })


        function update_band(uid, freq, band_bw) {
            data = {
                "uid": uid,
                "frequency": freq,
                "sample_rate": band_bw

            }
            $.ajax({
                type: 'POST',
                url: '/update_demode_settings',
                data: JSON.stringify(data),
                contentType: 'application/json',
                success: function (data) {
                    parent.decoder_bookmark12(uid)
                }
            })
        }





        var legendBuilder,legend_backgrd;
        if(page_theme =='light'){
            legendBuilder = LegendBoxBuilders.HorizontalLegendBox.styleEntries((entry) => entry
            .setTextFillStyle(new SolidFill({ color: ColorHEX('#000000') }))
            .setLUTLength(200)
            )
            legend_backgrd = "#ffffffcf"

        }
        else{
            legendBuilder = LegendBoxBuilders.HorizontalLegendBox.styleEntries((entry) => entry
            .setTextFillStyle(new SolidFill({ color: ColorHEX('#FFFFFF') }))
            .setLUTLength(200)
            )
            legend_backgrd = "#00000061"

        }

        
        var legend2 = waterFall
            .addLegendBox(legendBuilder)
            .setTitle(false)
            .setPosition({ x: 97.5, y: 92 })

        legend2.setBackground((background) => background
            .setFillStyle(new SolidFill({ color: ColorHEX(legend_backgrd) }))
            .setStrokeStyle(new SolidLine({ thickness: 1, fillStyle: new SolidFill({ color: ColorHEX('#FFFFFF') }) }))
        )
        legend2.add(heatmapSeries, { toggleVisibilityOnClick: false })
        legend2.setDraggingMode(0)


        function showLegendBox() {
            legend2.setVisible(true);
        }


        function hideLegendBox() {
            legend2.setVisible(false);
        }


        function delete_band(uid) {
            wxAxisBand[uid].dispose()
            xAxisBand[uid].dispose()
        }

        // cursor style
        chart.setAutoCursor((cursor) => cursor
            .setGridStrokeXStyle(new SolidLine({ thickness: 1, fillStyle: new SolidFill({ color: ColorRGBA(255, 255, 255) }) }))
        )


        function change_mod(val) {
            document.getElementById("modulation").value = val;
            document.getElementById("sample_rate_bm").value = banwidth_val_of_mode[document.getElementById("modulation").value]
            document.getElementById("name").value = val
        }


        // ##########################################################################


        auto_axis_btn = window.parent.document.getElementById('auto_y_axis')
        if (auto_axis_btn.checked) {
            auto_Y_axis_flag = true
        }


        peak_btn_parent = window.parent.document.getElementById('hide_peak')
        if (peak_btn_parent.checked) {
            peak_data_flag = true
        }


        auto_threshold_btn = window.parent.document.getElementById('auto_threshold')
        if (auto_threshold_btn.checked) {
            auto_threshold_flag = true
        }

        //----------------------- data source ------------------------

        //  =================== for traces ===================================
        
        const tFirst = performance.now()
        const dataArrayTimeDomain = new Array(dataSampleSize)
        const minValues = new Array(dataSampleSize_1).fill(Infinity)
        const maxValues = new Array(dataSampleSize_1).fill(-Infinity)
        const avgValues = new Array(dataSampleSize_1).fill(Infinity)


        function getAverage(array) {
            let sum = 0;
            for (let i = 0; i < array.length; i++) {
                sum += array[i];
            }
            return sum / array.length;
        }


        function open_loader() {
            // $('#websocket_loader').modal({backdrop : 'static'})
            $('#websocket_loader').modal('show')
        }


        function close_loader() {
            $('#websocket_loader').modal('hide')
        }


        // $(document).ready(function () {
        //     open_loader()
        //     setTimeout(function () {
        //         window.parent.iq_data()
        //     }, 500)
        // });


        // =================================   WEBSOCKET RECV DATA  ===========================================

        var cnt = 0;
        function websocket_data(evt) {
            dataVal = evt;
            if (dataVal.hasOwnProperty('message') === true) {
                if (dataVal['message'] == "connect") {
                    // $(window.parent.document).find('#websocket_loader').modal({backdrop : 'static'})
                    //  $(window.parent.document).find('#websocket_loader').modal('show')
                }
                if (dataVal['message'] == "connected") {
                    // setTimeout(function(){
                    //     $('#websocket_loader').modal('hide')
                    // },1000)
                }
            } else {
                if (auto_threshold_flag == true) {

                    av_int = getAverage(dataVal.y)
                    set_threshold(Math.round(av_int))
                }

                if (peak_data_flag == true) {
                    updateSeriespeak(dataVal.auto_data);
                }

                else {
                    seriespeak.clear()
                   
                }

                cnt += 1
                if (cnt == 3) {
                    reconfig_lut()
                }

                //  waterfall ====================
                handleIncomingData(time_counter, dataVal.y)
                time_counter = time_counter + 1

                // oscillioscope ==================

                // let framesCount = 0
                const frame = () => {
                    const tNow = performance.now()
                    if (tPrev) {

                        const waveformTimestamps = new Array(1024)
                            .fill(0)
                            .map((_, i, arr) => tPrev + ((tNow - tPrev) * (i + 1)) / arr.length)

                        // for (let i = 0; i < 1024; i++) {
                        seriesWaveform.appendSamples({
                            xValues: waveformTimestamps,
                            yValues: dataVal.time_domain,
                            // yValues: dataVal.y

                        })
                        chartWaveform.getDefaultAxisX()
                        // const fps = 1 / ((tNow - tFirst) / framesCount)
                        // }
                        // requestAnimationFrame(frame)
                        tPrev = tNow
                        // framesCount += 1
                    }
                }
                frame()
                //  spectrum ====================
                if (button_click_main == true) {
                    updateSeries(dataVal.x, dataVal.y);
                }

                //  =================== auto y axis =======================
                if (auto_Y_axis_flag == true) {
                    chart.getDefaultAxisY().setInterval({ start: -140, end: -20 }).setDefaultInterval({ start: (Math.min(...dataVal.y)), end: Math.max(...dataVal.y) })
                }
                else {

                    start_y = parseInt(window.parent.document.getElementById('minY').value)
                    stop_y = parseInt(window.parent.document.getElementById('maxY').value)
                    set_min_max_amp(start_y, stop_y)
                }

                //  ================== for traces =========================
                //  all truee
                if (button_click_max == true && button_click_min == true && button_click_avg == true) {

                    cycleData.push(dataVal);
                    if (cycleData.length > Max_cycles) {
                        cycleData.shift()

                        for (const cycle of cycleData) {
                            for (let i = 0; i < cycle.y.length; i++) {
                                minValues[i] = Math.min(minValues[i], cycle.y[i]);
                                maxValues[i] = Math.max(maxValues[i], cycle.y[i]);
                                avgValues[i] += cycle.y[i] / Max_cycles;
                            }
                        }
                        cycleData = [];

                        updateMax(dataVal.x, maxValues);
                        updateMin(dataVal.x, minValues);
                        updateAvg(dataVal.x, avgValues);
                        avgValues.fill(0);
                    }
                }

                // if max true
                if (button_click_max == true && button_click_min == false && button_click_avg == false) {

                    cycleData.push(dataVal);
                    if (cycleData.length > Max_cycles) {
                        cycleData.shift()

                        for (const cycle of cycleData) {
                            for (let i = 0; i < cycle.y.length; i++) {
                                maxValues[i] = Math.max(maxValues[i], cycle.y[i]);
                            }
                        }
                        const allOnes = maxValues.every(value => value === 1);
                        const allZeros = maxValues.every(value => value === 0);
                        if (allOnes || allZeros) {

                            maxValues.fill(-Infinity)
                            maxSeries.clear()
                        } else {
                            updateMax(dataVal.x, maxValues);
                            cycleData = [];
                        }
                        // cycleData = [];
                        // updateMax(dataVal.x, maxValues);
                    }
                }
                //  if max and min true
                if (button_click_max == true && button_click_min == true && button_click_avg == false) {
                    cycleData.push(dataVal);
                    if (cycleData.length > Max_cycles) {
                        cycleData.shift()
                        for (const cycle of cycleData) {
                            for (let i = 0; i < cycle.y.length; i++) {
                                minValues[i] = Math.min(minValues[i], cycle.y[i]);
                                maxValues[i] = Math.max(maxValues[i], cycle.y[i]);
                                avgValues[i] += cycle.y[i] / Max_cycles;

                            }
                        }
                        cycleData = [];
                        updateMax(dataVal.x, maxValues);
                        updateMin(dataVal.x, minValues);
                    }
                }
                // if min and avg true
                if (button_click_max == false && button_click_min == true && button_click_avg == true) {
                    cycleData.push(dataVal);
                    if (cycleData.length > Max_cycles) {
                        cycleData.shift()
                        for (const cycle of cycleData) {
                            for (let i = 0; i < cycle.y.length; i++) {
                                minValues[i] = Math.min(minValues[i], cycle.y[i]);
                                avgValues[i] += cycle.y[i] / Max_cycles;
                            }
                        }
                        cycleData = [];
                        updateMin(dataVal.x, minValues);
                        updateAvg(dataVal.x, avgValues);
                        avgValues.fill(0);

                    }
                }
                // if min true
                if (button_click_max == false && button_click_min == true && button_click_avg == false) {
                    cycleData.push(dataVal);
                    if (cycleData.length > Max_cycles) {
                        cycleData.shift()

                        for (const cycle of cycleData) {
                            for (let i = 0; i < cycle.y.length; i++) {
                                minValues[i] = Math.min(minValues[i], cycle.y[i]);
                                // maxValues[i] = Math.max(maxValues[i], cycle.y[i]);
                                // avgValues[i] += cycle.y[i] / Max_cycles;
                            }
                        }
                        cycleData = [];
                        // avgValues.fill(0);

                        updateMin(dataVal.x, minValues);

                    }
                }
                // if avg true
                if (button_click_max == false && button_click_min == false && button_click_avg == true) {
                    cycleData.push(dataVal);
                    if (cycleData.length > avg_max_cycle) {
                        cycleData.shift()
                        for (const cycle of cycleData) {
                            for (let i = 0; i < cycle.y.length; i++) {
                                avgValues[i] += cycle.y[i] / avg_max_cycle;
                            }
                        }
                        cycleData = [];
                        updateAvg(dataVal.x, avgValues);
                        avgValues.fill(0);


                    }
                }
                // if max and avg true
                if (button_click_max == true && button_click_min == false && button_click_avg == true) {
                    cycleData.push(dataVal);
                    if (cycleData.length > Max_cycles) {
                        cycleData.shift()
                        for (const cycle of cycleData) {
                            for (let i = 0; i < cycle.y.length; i++) {
                                maxValues[i] = Math.max(maxValues[i], cycle.y[i]);
                                avgValues[i] += cycle.y[i] / Max_cycles;
                            }
                        }
                        cycleData = [];
                        updateAvg(dataVal.x, avgValues);
                        updateMax(dataVal.x, maxValues);
                        avgValues.fill(0);
                    }
                }

                else if (button_click_max == false && button_click_min == false && button_click_avg == false) {
                    minValues.fill(Infinity)
                    maxValues.fill(-Infinity)
                    avgValues.fill(0)
                }
            }

            for (var i = 0; i <= chartMarker.length; i++) {

                if (mark_data_flag == true) {
                    for (var i = 0; i <= chartMarker.length; i++) {
                        if (chartMarker[i]) {

                            update_marker(i)
                        }

                    }

                }


            }
        }


        // ----------------------------------- ScreenShot Btn ------------------------------------


        document.getElementById('screenshot_img').onclick = function () {
            chart.saveToFile('Spectrum_screenshot')
        }


        function addMarkernew(x, y) {
            if(document.getElementById("mark_data_btn").checked == true)
            {
                i = counter
                if (i <= 4) {
                    var color = '#FFFFFF';

                    if (page_theme == 'light') {
                        color = "#0000FF"
                    }

                    $.ajax({
                    type: 'GET',
                    url: '/set_marker',
                    contentType: 'application/json',
                    success: function (res) {
                        var index = res.map(function(f) { return f.frequency; }).indexOf(x);
                        var marker_data=0
                        for(var l=0; l< res.length; l++){
                            var index = res.map(function(f) { return f.frequency; }).indexOf(x);
                            if( (res.findIndex(p => p.frequency == x))==-1){

                                if (chartMarker[i]) {
                                    chartMarker[i].dispose()
                                }
                                if (window.parent.removed_marker.length > 0) {
                                    for (var j = 0; j < window.parent.removed_marker.length; j++) {
                                        i = parseInt(window.parent.removed_marker[j])
                                        window.parent.removed_marker.splice(j, 1)
                                        break;
                                    }
                                }
                                else {
                                    i = counter
                                }
                                // console.log('add new marker',(res.findIndex(p => p.frequency == x)))
                                chartMarker[i] = chart.addChartMarkerXY()
                                chartMarker[i].setPosition({ x: x, y: y })
                                chartMarker[i].setMouseInteractions(true)
                                chartMarker[i].setPointMarker(marker => marker.setShape(PointShape.Diamond).setSize({ x: 12, y: 12 }).setFillStyle(new SolidFill({ color: ColorHEX(`${marker_color}`) }))).setResultTableVisibility(UIVisibilityModes.always).setGridStrokeXCut(true).setGridStrokeYCut(true).setResultTable((table) => table.setContent([[`M ${i + 1}`]])).setGridStrokeXVisibility(UIVisibilityModes.always).setGridStrokeYVisibility(UIVisibilityModes.always).setTickMarkerXVisibility(UIVisibilityModes.always).setTickMarkerYVisibility(UIVisibilityModes.always).setGridStrokeXStyle(new DashedLine({ fillStyle: new SolidFill({ color: ColorHEX("#a639f9") }) })).setGridStrokeYStyle(new DashedLine({ fillStyle: new SolidFill({ color: ColorHEX("#a639f9") }) }))


                                data = chartMarker[i].getPosition()
                                var frequency
                                var power
                                var marker_name
                                var data1 = {
                                    frequency: data.x,
                                    power: data.y,
                                    'marker_index': i,
                                    color: color
                                }

                                $.ajax({
                                    type: 'POST',
                                    url: "/get_marker_new",
                                    data: JSON.stringify(data1),
                                    dataType: 'json',
                                    success: function (data) {
                                        parent.marked_positions_table()
                                        set_marked_positions()
                                    },
                                    error: function (xhr, status, error) {
                                        console.error("Error :", error);
                                    },
                                });
                                counter = counter + 1
                                break;
                            }
                            else{
                                // console.log('dont add new marker',(res.findIndex(p => p.frequency == x)))
                                var tr = window.parent.document.getElementById(`table_row_${index}`)
                                highlight_fn(tr, 3);
                                break;
                            }
                        }
                    },
                        error: function (xhr, status, error) {
                            console.error("Error :", error);
                        },
                    });
                        
                    


                    
                }
                else {
                    counter = 4
                    addMarkerAgain(x, y)
                }
            }


        }


        function highlight_fn(inputElement, times) {
            for (let i = 0; i < times; i++) {
                inputElement.style.background = 'red';
                // inputElement.style.transform = 'scale(1.15)'
                inputElement.classList.add('transition_cls');
                setTimeout(() => {
                inputElement.style.background = '';
                inputElement.style.transform = 'scale(1)'

                }, 200);
                setTimeout(() => {
                inputElement.style.background = 'red';
                // inputElement.style.transform = 'scale(1.15)'
                inputElement.classList.add('transition_cls');


                }, 400);
                setTimeout(() => {
                inputElement.style.background = '';
                inputElement.style.transform = 'scale(1)'


                }, 600);
                setTimeout(() => {
                inputElement.style.background = 'red';
                // inputElement.style.transform = 'scale(1.15)'
                inputElement.classList.add('transition_cls');


                }, 800);
            }
            setTimeout(() => {
                inputElement.style.background = '';
                inputElement.style.transform = 'scale(1)'


            //    inputElement.value = '';
            }, 1000);
            inputElement.style.border = 'revert';
        // inputElement.style.border = 'revert';
      }
        function addMarkerAgain(x, y) {
            addMarkernew(x, y)
        }


        function set_marked_positions() {
            var Freq_number = parseFloat(parent.document.getElementById("Freq_number").value).toFixed(3);
            var Freq_value = parent.document.getElementById("Freq_value").value
            var sample_rate_value = parseFloat(parent.document.getElementById("sample_rate_value_text").value) * 1e6;
            if (Freq_value == "GHz") {
              Freq_number = parseInt(Freq_number * 1e9);
            }
            else if (Freq_value == "MHz") {
              Freq_number = parseInt(Freq_number * 1e6);
            }
            else if (Freq_value == "KHz") {
              Freq_number = parseInt(Freq_number * 1e3);
            }
            else {
              Freq_number = parseInt(Freq_number)
            }

            var start_frequency = Freq_number - parseInt(sample_rate_value / 2);
            var stop_frequency = Freq_number + parseInt(sample_rate_value / 2);
            $.ajax({
                type: 'GET',
                url: '/set_marker',
                contentType: 'application/json',
                success: function (data) {
                    var marker_data = 0
                    if (marker_data < 5) {
                        for (var i = 0; i < data.length; i++) {
                            if (chartMarker[i]) {
                                chartMarker[i].dispose()
                            }
                            var j = 0
                            local_store = data;
                            if (data[i].frequency != null) {
                                counter = data.length - 1
                                if (mark_data_flag == true) {
                                    chartMarker[i] = chart.addChartMarkerXY().setPosition({ x: data[i].frequency, y: data[i].power })
                                    chartMarker[i].setPointMarker(marker => marker.setShape(PointShape.Diamond).setSize({ x: 12, y: 12 }).setFillStyle(new SolidFill({ color: ColorHEX(`${marker_color}`) }))).setResultTableVisibility(UIVisibilityModes.always).setGridStrokeXCut(true).setGridStrokeYCut(true).setResultTable((table) => table.setContent([[`M${data[i].marker_index + 1}`]])).setGridStrokeXVisibility(UIVisibilityModes.always).setGridStrokeYVisibility(UIVisibilityModes.always).setTickMarkerXVisibility(UIVisibilityModes.always).setTickMarkerYVisibility(UIVisibilityModes.always).setGridStrokeXStyle(new DashedLine({ fillStyle: new SolidFill({ color: ColorHEX("#a639f9") }) })).setGridStrokeYStyle(new DashedLine({ fillStyle: new SolidFill({ color: ColorHEX("#a639f9") }) }))
                                    addMarkerData.push({ x: data[i].frequency, y: data[i].power });
                                    pos_x[i] = data[i].frequency
                                    if( data[i].frequency  < start_frequency/1e6 || data[i].frequency  > stop_frequency/1e6){
                                                parent.remove_marker(`M_${i}`)
                                                // console.log("Remove marker",i)
                                            }
                                }
                                else {
                                    console.log("Hii in else marker hide")
                                    hide_markers(data)

                                }
                            }
                            else {
                                if (!window.parent.removed_marker.includes(i)) {
                                    window.parent.removed_marker.push(i)
                                }
                            }
                            marker_data = marker_data + 1
                        }
                    }
                }
            })
        }

        function hide_markers(data) {
            for (var i = 0; i < data.length; i++) {
                if(chartMarker[i]){
                    if (chartMarker[i].getVisible()) {
                        chartMarker[i].setVisible(false);
                    }
                }
            }
        }


        series.onMouseDown((_, e) => {
            if (event.button !== 2) return
            rightMbPress = performance.now()
        });


        series.onMouseUp((_, e) => {
            if (!rightMbPress || performance.now() - rightMbPress > 500) return
            const locationAxis = chart.translateCoordinate(event, chart.coordsAxis)
            var x = locationAxis.x
            var y = locationAxis.y
            addMarkernew(x, y)
        })


        document.getElementById('csv_export').onclick = function () {
            var rows = [
                [
                    "Frequency(MHz)",
                    "Power(dBm)"
                ],
                ...dataVal.x.map((x, i) => ([(dataVal.x[i] * 1e-6).toFixed(3), dataVal.y[i].toFixed(1)]))]
                .map(e => e.join(","))
                .join("\n");
            let csvContent = "data:text/csv;charset=utf-8,"
                + rows;
            var encodedUri = encodeURI(csvContent);
            window.open(encodedUri);
        }


        // =============================================== update Markar =================================================

        function update_marker(i) {

            if (chartMarker[i]) {
                var pos = chartMarker[i].getPosition()
                pos_in_hz = pos.x * 1e6
                if (dataVal.x) {
                    var index = findClosest(dataVal.x, pos_in_hz)
                    chartMarker[i].setPosition({ x: pos.x, y: dataVal.y[index.index] })
                    window.parent.update_power(i, dataVal.y[index.index])
                }
            }

            if (pos_x[i]) {
                chartMarker[i].getPointMarker().onMouseDragStop(() => {
                    if (chartMarker[i]) {
                        // new_pos[i] = new_pos_q
                        new_pos[i] = chartMarker[i].getPosition().x
                        if (pos_x[i] != new_pos[i]) {
                            pos_x[i] = new_pos[i];
                            data = chartMarker[i].getPosition()
                            var frequency
                            var power
                            var marker_name
                            var data1 = {
                                frequency: data.x,
                                power: data.y,
                                'marker_index': i,
                                'color': '#FFFFFF'
                            }

                            $.ajax({
                                type: 'POST',
                                url: "/get_marker_new",
                                contentType: 'application/json',
                                data: JSON.stringify(data1),
                                dataType: 'json',
                                success: function (data) {
                                    parent.update_freq(i, chartMarker[i].getPosition().x)
                                    // set_marked_positions()
                                },
                                error: function (xhr, status, error) {
                                    console.error("Error :", error);
                                },
                            });


                        }
                    }

                });

                chartMarker[i].getTickMarkerX().onMouseDragStop(() => {
                    if (chartMarker[i]) {
                        // new_pos[i] = new_pos_q
                        new_pos[i] = chartMarker[i].getPosition().x
                        if (pos_x[i] != new_pos[i]) {
                            pos_x[i] = new_pos[i];
                            data = chartMarker[i].getPosition()
                            var frequency
                            var power
                            var marker_name
                            var data1 = {
                                frequency: data.x,
                                power: data.y,
                                'marker_index': i,
                                'color': '#FFFFFF'
                            }

                            $.ajax({
                                type: 'POST',
                                url: "/get_marker_new",
                                contentType: 'application/json',
                                data: JSON.stringify(data1),
                                dataType: 'json',
                                success: function (data) {
                                    parent.update_freq(i, chartMarker[i].getPosition().x)
                                    // set_marked_positions()
                                },
                                error: function (xhr, status, error) {
                                    console.error("Error :", error);
                                },
                            });
                        }
                    }
                });
            }
        }


        function findClosest(arr, target) {
            let n = arr.length;
            let i = 0, j = n - 1, mid = 0;

            // Corner cases
            if (target <= arr[0]) {
                return { "val": arr[0], "index": 0 };
            }
            if (target >= arr[n - 1]) {
                return { "val": arr[n - 1], "index": n - 1 };
            }

            // Binary search
            while (i <= j) {
                mid = Math.floor((i + j) / 2);

                // If target is found, return it immediately
                if (arr[mid] === target) {
                    return { "val": arr[mid], "index": mid };
                }

                // If target is less than arr[mid], search in the left half
                if (target < arr[mid]) {
                    j = mid - 1;
                }
                // If target is greater than arr[mid], search in the right half
                else {
                    i = mid + 1;
                }
            }

            // After binary search, i is the first element greater than the target
            // and j is the last element less than the target.
            // We compare the closest two values arr[j] and arr[i]
            if (i < n && arr[i] === target) {
                return { "val": arr[i], "index": i };
            }
            if (j >= 0 && arr[j] === target) {
                return { "val": arr[j], "index": j };
            }

            // Now determine the closest value
            let left = arr[j] !== undefined ? arr[j] : Infinity;
            let right = arr[i] !== undefined ? arr[i] : Infinity;

            if (Math.abs(target - left) <= Math.abs(target - right)) {
                return { "val": left, "index": j };
            } else {
                return { "val": right, "index": i };
            }
        }


        function get_data() {
            $.ajax({
                type: 'POST',
                url: '/get_demodulators_for_active_channel',
                data: JSON.stringify(),
                contentType: 'application/json',
                success: function (data) {

                    var valid_data = data['active']

                    for (var i = 0; i < valid_data.length; i++) {
                        // 
                        xAxisBand[valid_data[i]['uid']] = valid_data[i]

                        // delete_band(valid_data[i]['uid'])

                        addBand(valid_data[i]['start_frequency'], valid_data[i]['stop_frequency'], 100000, "myband1", valid_data[i]['uid'], valid_data[i]['color'])
                    }
                }
            });
        }


        function plot_all_demods() {

            $.ajax({
                type: 'POST',
                url: '/get_demodulators_for_active_channel',
                data: JSON.stringify(),
                contentType: 'application/json',
                success: function (data) {
                    var valid_data = data['active']

                    for (var i = 0; i < valid_data.length; i++) {
                        addBand(valid_data[i]['start_frequency'], valid_data[i]['stop_frequency'], 100000, valid_data[i]['name'], valid_data[i]['uid'], valid_data[i]['color'])
                    }
                }
            });
        }


        function reload_bands() {

            $.ajax({
                type: 'POST',
                url: '/get_demodulators_for_active_channel',
                data: JSON.stringify(),
                contentType: 'application/json',
                success: function (data) {

                    // removing existing bands
                    for (const [key, value] of Object.entries(wxAxisBand)) {
                        delete_band(key);
                    }

                    var valid_data = data['active']

                    for (var i = 0; i < valid_data.length; i++) {
                        addBand(valid_data[i]['start_frequency'], valid_data[i]['stop_frequency'], 100000, valid_data[i]['name'], valid_data[i]['uid'], valid_data[i]['color'])
                    }
                }
            });
        }


        function set_band() {

            $.ajax({
                type: 'POST',
                url: '/get_demodulators_for_active_channel',
                data: JSON.stringify(),
                contentType: 'application/json',
                success: function (data) {
                    var valid_data = data['active']

                    for (var i = 0; i < valid_data.length; i++) {
                        // addBand(valid_data[i]['frequency'], 100000, valid_data[i]['name'], valid_data[i]['uid'], valid_data[i]['color'])

                        xAxisBand[valid_data[i]['uid']].setValueStart(valid_data[i]['stop_frequency']).setValueEnd(valid_data[i]['start_frequency'])
                        wxAxisBand[valid_data[i]['uid']].setValueStart(valid_data[i]['stop_frequency']).setValueEnd(valid_data[i]['start_frequency'])
                    }

                }
            });

        }


        function full_screen() {
            var checkBox_full_screen = document.getElementById("full_screen");
            if (full_screen_flag == false) {
                document.getElementById('full_screen_label').innerHTML = `<i style='font-size:15px' data-bs-toggle="tooltip" data-bs-placement="left" title="Full Screen" class='fas fa-compress-arrows-alt'></i>`
                window.parent.document.getElementById("table_col").style.display = "none"
                //window.parent.document.getElementById("table_col_div").style.display = "none"
                window.parent.document.getElementById("iframe_col").className = "col-12"
                window.parent.document.getElementById("iframe_col").style.paddingRight = "25px"
                full_screen_flag = true

            }
            else {
                document.getElementById('full_screen_label').innerHTML = `<i style='font-size:15px' data-bs-toggle="tooltip" data-bs-placement="left" title="Full Screen" class='fas fa-expand-arrows-alt'></i>`
                window.parent.document.getElementById("table_col").style.display = "block"
                // window.parent.document.getElementById("table_col_div").style.display = "block"
                window.parent.document.getElementById("iframe_col").className = "col-8"
                window.parent.document.getElementById("iframe_col").style.paddingRight = "15px"
                full_screen_flag = false

            }
        }


        function update_traces_settings() {
            traces_json = { active_channel : active_channel,active_mode : active_mode,"button_click_max": button_click_max, "button_click_min": button_click_min, "button_click_avg": button_click_avg, "button_click_main": button_click_main,"enable_marker" : mark_data_flag ,"enable_peak" : peak_data_flag}
            $.ajax({
                type: 'POST',
                url: '/update_show_traces_settings',
                data: JSON.stringify(traces_json),
                contentType: 'application/json',
                success: function (data) {
                    traces_setting()
                }
            })
        }


        function traces_setting() {

            $.ajax({
                type: 'POST',
                url: '/get_show_traces_settings',
                data: JSON.stringify({ active_channel : active_channel,active_mode : active_mode }),
                contentType: 'application/json',
                success: function (data) {
                    console.log(data)
                    button_click_max = data['button_click_max']
                    button_click_min = data['button_click_min']
                    button_click_avg = data['button_click_avg']
                    button_click_main = data['button_click_main']
                    mark_data_flag = data['enable_marker']
                    peak_data_flag = data["enable_peak"]

                    if (button_click_max == true) {
                        document.getElementById("max_hold").checked = true
                    }
                    else {

                        document.getElementById("max_hold").checked = false
                    }

                    if (button_click_min == true) {
                        document.getElementById("min_hold").checked = true
                    }
                    else {

                        document.getElementById("min_hold").checked = false
                    }

                    if (button_click_avg == true) {
                        document.getElementById("avg_hold").checked = true
                    }
                    else {

                        document.getElementById("avg_hold").checked = false
                    }

                    if (button_click_main == true) {
                        document.getElementById("main_curve").checked = true
                    }
                    else {

                        document.getElementById("main_curve").checked = false
                    }
                    if (mark_data_flag == true) {
                        document.getElementById("mark_data_btn").checked = true
                        set_marked_positions()
                    }
                    else {

                        document.getElementById("mark_data_btn").checked = false
                    }
                    if (peak_data_flag == true) {
                        document.getElementById("peak_data_btn").checked = true
                
                    }
                    else {

                        document.getElementById("peak_data_btn").checked = false
                    }
                }
            });
        }


        function show_traces_max() {

            var checkBox_max = document.getElementById("max_hold");
            if (checkBox_max.checked == true) {
                button_click_max = true
                update_traces_settings()

            } else {
                button_click_max = false
                maxValues.fill(-Infinity)
                maxSeries.clear()
                update_traces_settings()
            }
        }   


        function show_traces_min() {

            var checkBox_min = document.getElementById("min_hold");
            if (checkBox_min.checked == true) {
                button_click_min = true
                update_traces_settings()

            }
            else {
                button_click_min = false
                minValues.fill(Infinity)
                minSeries.clear()
                update_traces_settings()
            }
        }


        function show_traces_avg() {

            var checkBox_avg = document.getElementById("avg_hold");
            if (checkBox_avg.checked == true) {
                button_click_avg = true
                update_traces_settings()

            }
            else {

                button_click_avg = false
                avgValues.fill(0)
                avgSeries.clear()
                update_traces_settings()

            }

        }


        function show_traces() {
        checkBox_Showtraces = document.getElementById('show_traces')
            if (checkBox_Showtraces.checked == true) {
                button_click_showtraces = true
            }
            else {
                button_click_showtraces = false
                maxValues.fill(-Infinity)
                maxSeries.clear()
                minValues.fill(Infinity)
                minSeries.clear()
                avgValues.fill(0)
                avgSeries.clear()
            }
        }


        function show_peak_data() {
            var checkBox_peak = document.getElementById("peak_data_btn");
            if (checkBox_peak.checked == false) {
                peak_data_flag = false
                update_traces_settings()
            }
            else {
                peak_data_flag = true
                seriespeak.clear()
                update_traces_settings()
            }

        }


        function show_mark_data() {
            var checkBox_mark = document.getElementById("mark_data_btn");
            if (checkBox_mark.checked == false) {
                mark_data_flag = false
                set_marked_positions()
                update_traces_settings()

            }
            else {
                mark_data_flag = true
                set_marked_positions()
                update_traces_settings()
            }
        }


        function show_main_curve() {
            var checkBox_main = document.getElementById("main_curve");
            if (checkBox_main.checked == true) {
                button_click_main = true
                update_traces_settings()

            }
            else {
                button_click_main = false
                series.clear()
                update_traces_settings()
            }
        }




        collapse_trace("dwn")
        waterfall_XYAxis()
        set_threshold1(data['threshold'])
        // set_marked_positions();
        traces_setting()
        // plot_all_demods();

    </script>
</body>


{% endblock %}