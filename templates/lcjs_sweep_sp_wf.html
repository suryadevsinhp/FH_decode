{% block content %}

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Spectrum and Water fall</title>


    <!-- Performance optimized script loading -->
    <script>
        // Performance configuration for sweep charts
        const PERFORMANCE_CONFIG_SWEEP = {
            MAX_DATA_POINTS: 6144,
            UPDATE_THROTTLE_MS: 40,
            CLEANUP_INTERVAL_MS: 12000,
            MAX_CIRCULAR_BUFFER_SIZE: 400,
            DEBOUNCE_DELAY_MS: 250
        };

        // DOM element cache for sweep charts
        const DOM_CACHE_SWEEP = {
            elements: new Map(),
            get(id) {
                if (!this.elements.has(id)) {
                    this.elements.set(id, document.getElementById(id));
                }
                return this.elements.get(id);
            },
            clear() { this.elements.clear(); }
        };
    </script>
    <link rel="preload" href="{{ url_for('static', filename='js/lcjs.iife.js')}}" as="script" />
    <link rel="stylesheet" type="text/css" href="{{ url_for('static', filename='css/bootstrap_4_lcjs.min.css')}}" />
    <link rel="stylesheet" type="text/css" href="{{ url_for('static', filename='css/font-awsome-4.7.min.css')}}" />
    <link rel="stylesheet" type="text/css" href="{{ url_for('static', filename='css/openwebrx.css')}}" />
    <link rel="stylesheet" href="{{ url_for('static', filename='css/fontawesome.all.min.css')}}">
    <link rel="stylesheet" href="{{ url_for('static', filename='css/fontawesome.min.css')}}">
    
    <script defer src="{{ url_for('static', filename='js/lcjs.iife.js')}}"></script>
    <script async src="{{ url_for('static', filename='js/bootstrap.bundle_4_lcjs.min.js')}}"></script>
    <script async src="{{ url_for('static', filename='lib/jquery/jquery.js')}}"></script>
    <script async src="{{ url_for('static', filename='lib/popper.js/popper.js')}}"></script>
    <script async src="{{ url_for('static', filename='lib/bootstrap/bootstrap.js')}}"></script>
    <script async src="{{ url_for('static', filename='bootstrap/bootstrap.min.js')}}"></script>
    <script async src="{{ url_for('static', filename='lib/perfect-scrollbar/js/perfect-scrollbar.jquery.js')}}"></script>
    <script async src="{{ url_for('static', filename='lib/moment/moment.js')}}"></script>
    <script async src="{{ url_for('static', filename='js/moment.min.js')}}"></script>
    <script async src="{{ url_for('static', filename='js/fontawesome.all.min.js')}}"></script>
    <script async src="{{ url_for('static', filename='js/fontawesome.min.js')}}"></script>
    <script async src="{{ url_for('static', filename='lib/jquery-ui/jquery-ui.js')}}"></script>



    <style>

        #lcjs-auto-flexbox{
            background-color: transparent;
            will-change: transform;
            }

        canvas{
            background-color: transparent;
            will-change: transform;
            }

        body{
            background-color: transparent;
            }

        /* Performance optimizations */
        .gpu-accelerated {
            transform: translateZ(0);
            backface-visibility: hidden;
            perspective: 1000;
        }

        .full-screen-div {
            position: absolute;
            color: rgb(0, 0, 0);
            top: 38px;
            right: 29px;
            z-index: 1001;
            height: 25px;
            width: 25px;

        }

        .screen-shot-div {
            position: absolute;
            color: rgb(0, 0, 0);
            top: 38px;
            right: 42px;
            z-index: 1001;
            height: 25px;
            width: 25px;
        }

        #trace_dwn {

            position: absolute;

            top: 15px;
            right: 30px;
            z-index: 1001;


        }

        #trace_up {

            position: absolute;
            top: 15px;
            right: 30px;
            z-index: 1001;


        }

        #outer_trace {
            padding-top: 2px;
        }

        /* #tracemenu{
            padding: 5px 5px 0px 5px;
            } */
        #custom-legend {
            background:rgb(0, 0, 0, 38%);
            padding: 10px;
            border: 1px solid #FFFFFF;
            /* border-radius: 5px; */
            color: white;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.2);
            position: absolute;
            top: 22px;
            right: 30px;
            z-index: 1000;
/*            height: 220px;*/
            width: 116px;
            transition:
                width 2s,
                height 2s,
                background-color 2s,
        }

        #custom_legend_camera {
            background: transparent;
            padding: 5px;
            border-radius: 5px;
            color: white;
            /* box-shadow: 0 0 10px rgba(0, 0, 0, 0.2); */
            position: absolute;
            left: 0px;
            bottom: 0px;
            z-index: 1000;
            height: auto;
            width: auto;
        }

        .legend-item {
            display: flex;
            align-items: center;
            margin-bottom: 5px;
            font-size: small;
        }

        .legend-checkbox {
            appearance: none;
            -webkit-appearance: none;
            -moz-appearance: none;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            border: 2px solid #ccc;
            outline: none;
            cursor: pointer;
            margin-right: 8px;
            position: relative;
        }

        .legend-checkbox:checked::after {
            content: "";
            display: block;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background-color: #d79c3c;
            position: absolute;
            /* top: 50%;
            left: 50%;
            transform: translate(-50%, -50%); */
        }



        .modal {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 1;
            background-color: rgba(0, 0, 0, 0.5);
            /* padding: 20px; */
            border-radius: 10px;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
        }


        .modal-content {
            background-color: #ffffff;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
        }


        .close {
            /* text-align: center; */
            background-color: #444;
            color: #fff;
            border: solid white 0.5mm;
            padding: 10px 10px;
            font-size: 11px;
            cursor: pointer;

        }

        .close:hover {
            background-color: #555;
        }


        .modal-content {
            background-image: linear-gradient(to bottom, #333, #444);
            background-image: -webkit-linear-gradient(top, #333, #444);
            background-image: -moz-linear-gradient(top, #333, #444);
            background-image: -ms-linear-gradient(top, #333, #444);
            background-image: -o-linear-gradient(top, #333, #444);
        }


        .modal {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 1;
            width: fit-content;
            height: fit-content;
        }


        #triggerModal:hover+#alert_ch_modal {
            display: block;
        }

        .openwebrx-dialog {
            background-color: #0e1011;

        }

        .openwebrx-text {
            font-weight: bolder;
            font-family: "Roboto", "Helvetica Neue", Arial, sans-serif;
        }
    </style>

</head>

<body>

    <div class="modal modal-backdrop fade" id="websocket_loader" tabindex="-1" role="dialog aria-labelledby="
        MultipleDeleteTargetModelLabel>
        <div class="modal-dialog modal-dialog-centered text-center " role="document">
            <div class="modal-body " style="width:1000px;">
                <!-- <div class="card" style="border: 1px solid var(--green-custom-color);"> -->
                <div class="m-0 px-0 py-5" style="background-color:white">
                    <i class="fa fa-spinner fa-spin fa-4x" style="color:black"></i>
                </div>
                <!-- </div> -->
            </div>
        </div>
    </div>
    <div class="full-screen-div ml-1">
        <div class="">
            <label for="full_screen" class="full_screen uil uil-expand-arrows-alt" id="full_screen_label"
                style="color: #ffffff; cursor: pointer;" onclick="full_screen()"><i style='font-size:15px'
                    data-bs-toggle="tooltip" data-bs-placement="left" title="Full Screen"
                    class='fas fa-expand-arrows-alt'></i></label>
        </div>
    </div>

    <!-- <div class="screen-shot-div ml-1">
    <div class="">
        <button style="color: white;background-color: transparent;border: 0px;" title="Screenshot" id="screenshot_img"><i class="fa fa-camera" aria-hidden="true"></i>
        </button>
    </div>
</div> -->

    <div id="custom-legend">
        <div id="outer_trace">
            <label for="" id="traces_label">Traces</label>

            <i class="fa fa-caret-down" id="trace_dwn" style="display: block;" onclick="collapse_trace('dwn')"></i>
            <i class="fa fa-caret-up" id="trace_up" style="display:none ;" onclick="collapse_trace('up')"></i>

            <div id="tracemenu" style="display:none ;">
                <div class="legend-item">
                    <input type="checkbox" class="legend-checkbox" id="main_curve"  onclick="show_main_curve()">
                    <label for="main_curve" class="main_curve" style="color: green;" id="main_curve_label">Main-Curve</label>
                </div>
                <div class="legend-item">
                    <input type="checkbox" class="legend-checkbox" id="avg_hold" checked onclick="show_traces_avg()">
                    <label for="avg_hold" class="avg_hold" id="avg_hold_label" >Avg-hold</label>
                </div>
                <div class="legend-item">
                    <input type="checkbox" class="legend-checkbox" id="max_hold" onclick="show_traces_max()">
                    <label for="max_hold" class="max_hold" style="color:  #8300c4 ;">Max-Hold</label>
                </div>
                <div class="legend-item">
                    <input type="checkbox" class="legend-checkbox" id="min_hold" onclick="show_traces_min()">
                    <label for="min_hold" class="min_hold" style="color: #37a6de">Min-Hold</label>
                </div>
                <div class="legend-item">
                    <input type="checkbox" class="legend-checkbox" id="persistence_data_btn" checked
                        onclick="show_traces_persis()">
                    <label for="persistence_data_btn" class="peak_data_btn" style="color:red;">Persistence</label>
                </div>
                <div class="legend-item">
                    <input type="checkbox" class="legend-checkbox" id="peak_data_btn" checked
                        onclick="show_peak_data()">
                    <label for="peak_data_btn" class="peak_data_btn" style="color: #66cc35;">Peaks</label>
                </div>
                <div class="legend-item">
                    <input type="checkbox" class="legend-checkbox" id="mark_data_btn" checked
                        onclick="show_mark_data()">
                    <b><label for="mark_data_btn" id="marker_color_label" class="mark_data_btn"
                        style="color:#d7d6db">Markers</label></b>
                </div>
                 <div class="legend-item">
                    <input type="checkbox" class="legend-checkbox" id="band" checked
                        onclick="show_traces_band()">
                        <b><label for="band" id="band_label" class="mark_data_btn"
                        style="color:#ff7800">Monitor</label></b>
                </div>
            </div>
        </div>
    </div>
    <div id="custom_legend_camera">
        <button style="color: white;background-color: transparent;border: 0px solid;" title="Screenshot"
            id="screenshot_img"><i class="fa fa-camera" aria-hidden="true"></i>
        </button>
        <button style="color: white;background-color: transparent;border: 0px solid;" title="Export to csv"
            id="csv_export"><i class="fa fa-solid fa-file-csv"></i>
        </button>
        <button style="color: white;background-color: transparent;border: 0px solid;" id="full_screen_btn" class="mx-1"
            title="ChartView" onclick="window.parent.full_screen_chart()"><i id="full_screen_icon"
                class="fa fa-solid fa-expand"></i>
        </button>
    </div>


    <div id="openwebrx-dialog-bookmark" class="openwebrx-dialog card"
        style="display:none; width: fit-content;">
        <form>
            <div style="margin: 5px;">
                <div class="form-field mx-auto">
                    <h6>
                        <center>
                            Monitor
                        </center>
                    </h6>
                </div>
                <hr>
            

                <di4v class="form-field">
                    <label for="frequency" class="tx-15">Frequency:</label>
                    <div style="display:flex;">
                        <input type="number" id="frequency" value=95 name="frequency">
                        <select name="unit" id="unit" onclick="changes_dropdown_value(this)">
                            <option value="khz">kHz</option>
                            <option value="mhz" selected>MHz</option>
                            <option value="ghz">GHz</option>
                        </select>
                    </div>

                </div>


                <div class="buttons" style="border-top:none !important;">
                    <!-- <label></label>
                    <div class="openwebrx-button mr-2 tx-15" onclick="change_mod('am')">AM</div>
                    <div class="openwebrx-button mr-2 tx-15" onclick="change_mod('nbfm')">NFM</div>
                    <div class="openwebrx-button mr-2 tx-15" onclick="change_mod('lsb')">SSB</div>
                    <div class="openwebrx-button tx-15" onclick="change_mod('dmr')">DMR</div> -->
                </div>

                <div class="form-field">
                    <label for="name" class="tx-15">Bandwidth:</label>
                    <input readonly type="text" class="tx-bold" id="realtime_ch_bandwidth" name="name" value="bandwidth">
                </div>



                <div class="form-field">
                    <label for="modulation" class="tx-15">Realtime Channel:</label>
                    <select name="modulation" id="realtime_channel" onchange="realtime_band_info()">

                        <!-- <option value="channel2" selected>Channel 2</option> -->

                    </select>
                </div>


                <div class="buttons">
                    <div class="openwebrx-button" onclick="get_bookmark_data_clear()">Cancel</div>
                    <div class="openwebrx-button" onclick="get_bookmark_data()">Ok</div>
                </div>
                <!-- <input on="submit" style="display:none;"> -->
        </form>
    </div>
    </div>

    <!--  Alert modal for active channel -->

    <div class="modal" id="alert_ch_modal">
        <div class="modal-content">
            <h2 style="color: #f00f0f; text-align: center;"><strong></strong></h2>
            <p style="color: #f0eaea;">Please Activate Monitoring Channel.</p>
            <button class="close" id="closeModal">Close</button>
        </div>
    </div>



    <!-- --------------------------------- Script ------------------------------ -->
    <script type="text/javascript">

        let button_click_max = false
        let button_click_min = false
        let button_click_avg = false
        let button_click_main = false
        var button_click_band = true
        var band_count_sweep = 0
        var auto_Y_axis_flag = false
        var peak_data_flag = true
        var button_click_peak = false
        var auto_threshold_flag = false
        var button_click_persistence = false

        var wxAxisBand = {};
        var xAxisBand = {};
        var bandLine = {};
        var wBandLine = {};
        var band_meta = {};
        var constantLine1;
        var constantLine2

        var active_port = "{{active_port}}";
        var peak_port = "{{peak_port}}"
        var active_channel = "{{active_channel}}";
        var active_mode = "{{active_mode}}";
        var page_theme = "{{theme_mode}}"
        var spectrum_data = JSON.parse('{{ spectrum_data | tojson | safe}}');
        var type_of_mode = {
            "fm": "audio",
            "wfm": "audio",
            "drm": "audio",
            "am": "audio",
            "lsb": "audio",
            "usb": "audio",
            'dmr': "data",
            'dstar': "audio",
            'nxdn': "audio",
            'ysf': "audio",
            'm17': "audio",
            'nbfm': "audio"
        }

        var unit_conversion = {
            "khz": 1e3,
            "mhz": 1e6,
            "ghz": 1e9
        }

        var freq = spectrum_data['freq']
        var start_freq = spectrum_data['start_frequency'] / 1e6
        var stop_freq = spectrum_data['stop_frequency'] / 1e6
        var start_WF_freq = spectrum_data['start_frequency'] / 1e6
        var stop_WF_freq = spectrum_data['stop_frequency'] / 1e6
        var sample_length = spectrum_data['sample_points']
        var page_mode = spectrum_data['mode']
        // const dataSampleSize = sample_length
        var sampleRateHz = 100
        var heatmapMinTimeStepMs = 1  // 1 millisecond

        var full_screen_flag = false

        let rightMbPress

        var mark_data_flag = true
        var clicks = 0;
        var addMarkerData = new Array();

        var viewMs = 100
        var time_counter = 100 // change in value also dosent affect anything
        var waterFall;
        var chart;
        var marker_color, theme_color, threshold_color;
        var chartMarker = [];
        var counter = 0
        var local_store, pos_x = [5], new_pos = [5]

        Max_cycles = 1;
        avg_max_cycle = 1;
        let cycleData = [];
        let dataSampleSize_1 = sample_length
        var dataVal, cnt = 0;
        var heatmapSeries
        var x = 0.2


        if(page_mode == "sweep"){
            document.getElementById('full_screen_label').innerHTML = `<i style='font-size:15px' data-bs-toggle="tooltip" data-bs-placement="left" title="Full Screen" class='fas fa-compress-arrows-alt'></i>`
            window.parent.document.getElementById("table_div").style.display = "none"
            window.parent.document.getElementById("iframe_div").className = "col-12"
            window.parent.document.getElementById("table_col_div").style.display = "none"
            window.parent.document.getElementById("iframe_div").style.paddingRight = "15px"
            full_screen_flag = true

        }
        function full_screen() {
            var checkBox_full_screen = document.getElementById("full_screen");
            if (full_screen_flag == false) {
                document.getElementById('full_screen_label').innerHTML = `<i style='font-size:15px' data-bs-toggle="tooltip" data-bs-placement="left" title="Full Screen" class='fas fa-compress-arrows-alt'></i>`
                window.parent.document.getElementById("table_div").style.display = "none"
                window.parent.document.getElementById("iframe_div").className = "col-12"

                window.parent.document.getElementById("iframe_div").style.paddingRight = "15px"

              // console.log('in full screen function')
                full_screen_flag = true
                if(page_mode == 'sweep'){
                    window.parent.document.getElementById("table_div").style.display = "none"
                    window.parent.document.getElementById("table_col_div").style.display = "none"
                    window.parent.document.getElementById("iframe_div").className = "col-12"
                    window.parent.document.getElementById("iframe_div").style.paddingRight = "15px"

                }

            }
            else {
                document.getElementById('full_screen_label').innerHTML = `<i style='font-size:15px' data-bs-toggle="tooltip" data-bs-placement="left" title="Full Screen" class='fas fa-expand-arrows-alt'></i>`
                window.parent.document.getElementById("table_div").style.display = "block"
                window.parent.document.getElementById("iframe_div").className = "col-8"
                window.parent.document.getElementById("iframe_div").style.paddingRight = "5px"
                if(page_mode == 'sweep'){
                    window.parent.document.getElementById("table_div").style.display = "block"
                    window.parent.document.getElementById("table_col_div").style.display = "block"
                    window.parent.document.getElementById("iframe_div").className = "col-8"
                    window.parent.document.getElementById("iframe_div").style.paddingRight = "5px"



                }
                full_screen_flag = false

            }
        }


        function collapse_trace(event) {

            if (event == "dwn") {
                document.getElementById("trace_dwn").style.display = "none"
                document.getElementById("trace_up").style.display = "block"
                document.getElementById("custom-legend").style.height = "230px"
                document.getElementById("tracemenu").style.display = "block"
                document.getElementById("outer_trace").style.paddingBottom = "0px"
                if(active_channel.slice(0,-1) == "REPLAY"){

                document.getElementById("custom-legend").style.height = "205px"
                document.getElementById("band").style.display = "none"
                document.getElementById("band_label").style.display = "none"

                }
                else{
                    document.getElementById("custom-legend").style.height = "230px"
                    document.getElementById("band").style.display = "block"
                    document.getElementById("band_label").style.display = "block"

                }

            } else {
                document.getElementById("trace_dwn").style.display = "block"
                document.getElementById("trace_up").style.display = "none"
                document.getElementById("custom-legend").style.height = "40px"
                document.getElementById("outer_trace").style.paddingBottom = "5px"
                document.getElementById("tracemenu").style.display = "none"

                // height: 195px;
            }
            
        }


       



        // =================== lc js import ====================
        const {
            lightningChart, DashedLine, PalettedFill, LUT, ColorHSV, emptyLine, AxisScrollStrategies, AxisTickStrategies, SolidFill, Themes,
            LegendBoxBuilders, UIElementBuilders, UIOrigins, AutoCursorModes, UIVisibilityModes, UIDraggingModes, SolidLine,
            regularColorSteps, synchronizeAxisIntervals, Axis, onMouseDoubleClick, ColorRGBA, setLabel, removeMarker, ColorHEX, PointShape, emptyFill
        } = lcjs;


         


        // ==================== dashboard ========================= Dashboard to divide into waterfall and spectrum

        if (page_theme == 'dark') {
            const dashboard = lcc.Dashboard({
                numberOfColumns: 1,
                numberOfRows: 2,
                // theme: Themes.light,//extra themes for dashboard
            })
            waterFall = dashboard.createChartXY({
                rowIndex: 1,
                columnIndex: 0,
                container: 'waterFallContainer',
                Width: 70
            })

            chart = dashboard.createChartXY({
                container: 'chartContainer',// Specify the container element
                rowIndex: 0,
                columnIndex: 0,
            });

        }
        else {
            const dashboard = lcc.Dashboard({
                numberOfColumns: 1,
                numberOfRows: 2,
                theme: Themes.light,//extra themes for dashboard
            })
            waterFall = dashboard.createChartXY({
                rowIndex: 1,
                columnIndex: 0,
                container: 'waterFallContainer',
                Width: 70
            })

            chart = dashboard.createChartXY({
                container: 'chartContainer',// Specify the container element
                rowIndex: 0,
                columnIndex: 0,

            });
        }


        // ==================== waterfall Axis FUNCTIONS in dashboard =========================
        function waterfall_XYAxis() {

            waterFall.setTitle(false)
                .getDefaultAxisY()
                .setTitle('Time')
                .setScrollStrategy(AxisScrollStrategies.progressive)
                .setTickStrategy(AxisTickStrategies.Time, tickStrategy => tickStrategy
                    .setTickStyle(ticks => ticks
                        .setLabelFont(font => font.setSize(12))
                        .setTickStyle(emptyLine)
                    )
                )

            waterFall.getDefaultAxisX().setTitle('Frequency (Hz)')//.setInterval({ start: -140, end: 1850 })

            //disable cursor
            waterFall.setAutoCursorMode(AutoCursorModes.disabled)
                .setMouseInteractionRectangleFit(true)

                try {
                    var wf_speed = window.parent.document.getElementById('waterfall_speed').value;

                    if (wf_speed === 'fast') {
                        viewMs = 100;
                        heatmapMinTimeStepMs = 5
                    } else if (wf_speed === 'medium') {
                        viewMs = 1024;
                        heatmapMinTimeStepMs = 1
                    } else if (wf_speed === 'slow') {
                        viewMs = 2048;
                        heatmapMinTimeStepMs = 0.5
                    } else {
                        viewMs = 100;
                    }
                    waterFall.getDefaultAxisY().setDefaultInterval((state) => ({ end: state.dataMax, start: (state.dataMax ?? 0) - viewMs, stopAxisAfter: false }))
                }
                catch (error) {
                    viewMs = 100;
                }

            waterFall.getDefaultAxisY().setDefaultInterval((state) => ({ end: state.dataMax, start: (state.dataMax ?? 0) - viewMs, stopAxisAfter: false }))
        }


        // ==================== waterfall COLOR constants in dashboard =========================

        const theme = waterFall.getTheme()
        var lut = new LUT({
            // steps: regularColorSteps(0, 75, theme.examples.spectrogramColorPalette),
            steps: [
                    { value: -20, color: ColorHEX(parent.max_step) },//green
                    { value: -70, color: ColorHEX(parent.mid_step1) },//red
                    { value: -110, color: ColorHEX(parent.min_step) },//green


                ],
            units: 'dBm',
            interpolate: true,
        })
        var paletteFill = new PalettedFill({ lut, lookUpProperty: 'value' })
        // ==================== ======================================= =========================


        //  colour adding to series (spectrum)
        const fillRed = new SolidFill({ color: ColorRGBA(255, 0, 0, 255) })
        const fillYellow = new SolidFill({ color: ColorHEX('#FFFF00') })
        const fillBlue = new SolidFill({ color: ColorHEX('#37a6de') })
        const fillGreen = new SolidFill({ color: ColorHEX('#008000') })
        const fillNavyBlue = new SolidFill({ color: ColorHEX('#00008B') })
        const fillBlack = new SolidFill({ color: ColorHEX('#000000') })
        const fillQSRGreen = new SolidFill({ color: ColorHEX('#66cc35') })
        const fillPurple = new SolidFill({ color: ColorHEX('#8300c4') })
       

        // ================================================== Spectrum Start===================================================

        // const maxSeries = chart.addPointLineAreaSeries().setName('Max Hold').setStrokeStyle((stroke) => stroke.setThickness(-1));
        const maxSeries = chart.addLineSeries().setName('Min Hold').setStrokeStyle((stroke) => stroke.setThickness(1))
        const persistenceSeries = chart.addPointLineAreaSeries({sizes:true}).setStrokeStyle((stroke) => stroke.setThickness(-1)).setPointSize(0).setPointFillStyle(new SolidFill({ color: ColorRGBA(255, 0, 0,100) })).setName('Persistence Hold')

        const series = chart.addLineSeries().setStrokeStyle((stroke) => stroke.setThickness(-1));
        const minSeries = chart.addLineSeries().setName('Min Hold').setStrokeStyle((stroke) => stroke.setThickness(-1));
        const avgSeries = chart.addLineSeries().setName('Avg Hold').setStrokeStyle((stroke) => stroke.setThickness(1));

        const seriespeak = chart.addPointSeries({ pointShape: PointShape.Circle })
            .setPointSize(12).setAutoScrollingEnabled(false)

        // Customize the chart appearance
        chart.setTitle(false);
        chart.getDefaultAxisX().setInterval({ start: start_freq, end: stop_freq });
        chart.getDefaultAxisY().setTitle('Amplitude (dBm)')
        chart.setMouseInteractionWheelZoom(true)

        chart.setPadding({ left: 20 })

        //===============================>>>>>>>>>>> Function to generate data from arrays

        function generateData(xArray, yArray) {
            // console.log(xArray,yArray)
            return xArray.map((x, i) => ({ x: xArray[i] / 1e6, y: yArray[i] }));
        }


        // Function to update the series with new data
        function updateSeries(xArray, yArray) {

            series.clear();
            series.add(generateData(xArray, yArray));
        }


        function updateMin(xArray, yArray) {
            // console.log("updateMin")
            minSeries.clear();
            minSeries.add(generateData(xArray, yArray));

        }


        function updateMax(xArray, yArray) {
            // console.log(xArray, yArray,"list dataatata")
            maxSeries.clear();
            maxSeries.add(generateData(xArray, yArray));
        
        }


        function updateAvg(xArray, yArray) {
            
            avgSeries.clear();
            avgSeries.add(generateData(xArray, yArray));
        }

        

        function updateSeriespeak(data) {
            seriespeak.clear();
            seriespeak.add(data);


        }
       
        function updatePersistence(xArray, yArray) {
            // console.log("HI update")
            persistenceSeries.clear();
            persistenceSeries.add(generateData(xArray, yArray));
            // console.log("HI update end")

        }
       persistenceSeries.setAreaFillStyle(new SolidFill({ color: ColorRGBA(255, 0, 0,50) }))

        if (page_theme == 'light') {
            series.setStrokeStyle((stroke) => stroke.setFillStyle(fillGreen))
            avgSeries.setStrokeStyle((stroke) => stroke.setFillStyle(fillNavyBlue))

            chart
                .setBackgroundFillStyle(new SolidFill({ color: ColorHEX('#F5F5F5') }))
                .setSeriesBackgroundFillStyle(new SolidFill({ color: ColorHEX('#F5F5F5') }))
                .setSeriesBackgroundStrokeStyle(new SolidLine({ thickness: 2, fillStyle: new SolidFill({ color: ColorRGBA(255, 255, 255) }) }))
            chart.getDefaultAxisY().setTitle('Amplitude (dBm)').setTickStrategy(AxisTickStrategies.Numeric, tickStrategy => tickStrategy
                .setTickStyle(ticks => ticks
                    // .setLabelFont(font => font.setSize(12))
                    // .setTickStyle(ticks => ticks
                    .setGridStrokeStyle((new SolidLine({ thickness: 1, fillStyle: new SolidFill({ color: ColorRGBA(128, 128, 128) }) })))
                    // )
                )
            )
            chart.getDefaultAxisX().setAxisInteractionReleaseByDoubleClicking(false).setTickStrategy(AxisTickStrategies.Numeric, tickStrategy => tickStrategy
                .setTickStyle(ticks => ticks
                    // .setLabelFont(font => font.setSize(12))
                    // .setTickStyle(ticks => ticks
                    .setGridStrokeStyle((new SolidLine({ thickness: 1, fillStyle: new SolidFill({ color: ColorRGBA(128, 128, 128) }) })))
                    // )
                )
            )//.setInterval({ start: 138.2, end: 147.8, stopAxisAfter: true })
            waterFall
                .setBackgroundFillStyle(new SolidFill({ color: ColorHEX('#F5F5F5') }))
                .setSeriesBackgroundFillStyle(new SolidFill({ color: ColorHEX('#F5F5F5') }))
                .setSeriesBackgroundStrokeStyle(new SolidLine({ thickness: 2, fillStyle: new SolidFill({ color: ColorRGBA(255, 255, 255) }) }))
            waterFall.getDefaultAxisY().setTitle('Amplitude (dBm)').setTickStrategy(AxisTickStrategies.Numeric, tickStrategy => tickStrategy
                .setTickStyle(ticks => ticks
                    // .setLabelFont(font => font.setSize(12))
                    // .setTickStyle(ticks => ticks
                    .setGridStrokeStyle((new SolidLine({ thickness: 1, fillStyle: new SolidFill({ color: ColorRGBA(128, 128, 128) }) })))
                    // )
                )
            )
            waterFall.getDefaultAxisX().setAxisInteractionReleaseByDoubleClicking(false).setTickStrategy(AxisTickStrategies.Numeric, tickStrategy => tickStrategy
                .setTickStyle(ticks => ticks
                    // .setLabelFont(font => font.setSize(12))
                    // .setTickStyle(ticks => ticks
                    .setGridStrokeStyle((new SolidLine({ thickness: 1, fillStyle: new SolidFill({ color: ColorRGBA(128, 128, 128) }) })))
                    // )
                )
            )
            marker_color = '#FF13F0'
            theme_color = "#000000"
            threshold_color = '#000000'

            // document.getElementById('main_curve_label').style.color = '#0827F5'
            document.getElementById('avg_hold_label').style.color = '#0827F5'
            document.getElementById('trace_dwn').style.color = '#4B5320'
            document.getElementById('trace_up').style.color = '#4B5320'
            document.getElementById('traces_label').style.color = '#4B5320'
            document.getElementById('custom-legend').style.background = '#ffffffcf'
            document.getElementById('full_screen_label').style.color = '#4B5320'
            document.getElementById('screenshot_img').style.color = '#4B5320'
            document.getElementById('csv_export').style.color = '#4B5320'
            document.getElementById('full_screen_btn').style.color = '#4B5320'


        }
        else {
            series.setStrokeStyle((stroke) => stroke.setFillStyle(fillGreen))
            avgSeries.setStrokeStyle((stroke) => stroke.setFillStyle(fillYellow))
            marker_color = '#FF13F0'
            theme_color = '#808080'
            threshold_color = '#FFFFFF'
            document.getElementById('avg_hold_label').style.color = '#FFFF00'
            document.getElementById('trace_dwn').style.color = threshold_color
            document.getElementById('trace_up').style.color = threshold_color
            document.getElementById('traces_label').style.color = threshold_color
            document.getElementById('full_screen_label').style.color = threshold_color
            // parent.document.getElementById('iq_record_status_pop').style.color = threshold_color

        }
        maxSeries.setStrokeStyle((stroke) => stroke.setFillStyle(fillPurple))
        minSeries.setStrokeStyle((stroke) => stroke.setFillStyle(fillBlue))
        // avgSeries.setStrokeStyle((stroke) => stroke.setFillStyle(fillGreen))
        seriespeak.setPointFillStyle(fillQSRGreen)
        persistenceSeries.setStrokeStyle((stroke) => stroke.setFillStyle(fillRed))

        document.getElementById("marker_color_label").style.color = marker_color

        function get_bookmark_data_clear() {
            document.getElementById('openwebrx-dialog-bookmark').style.display = "none";
        }

        // chart.setPadding({ left: 50 })



        // =================================================== End Spectrum chart===================================================

        //=========================================== synchronize Axis ======================================================
        synchronizeAxisIntervals(waterFall.getDefaultAxisX(), chart.getDefaultAxisX());
        var freqDict = [];

        //  convert color hexToRgb
        function hexToRgb(hex) {
            var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? {
                r: parseInt(result[1], 16),
                g: parseInt(result[2], 16),
                b: parseInt(result[3], 16)
            } : null;

        }

        var realtime_band_data;
        function get_realtime_config(){
            $.ajax({
                type: 'GET',
                url: '/get_realtime_config',
                contentType: 'application/json',
                success: function (data) {
                    // console.log("-------",data)
                        // document.getElementById("realtime_ch_bandwidth").value = realtime_channel['sample_rate']/1e6
                        realtime_band_data = data;
                        var html = '';
                        data.forEach(realtime_channel => {
                            var ch_num = realtime_channel['channel'].charAt(realtime_channel['channel'].length - 1);
                            html += `<option value="${realtime_channel['channel']}" >Channel ${ch_num}</option>`
                        });
                        document.getElementById('realtime_channel').innerHTML = html
                        if(data.length > 0){
                            document.getElementById("realtime_ch_bandwidth").value = data[0]['sample_rate']/1e6
                            document.getElementById("realtime_channel").value = data[0]['channel']
                        }
                    }})
        }

        function realtime_band_info(){

            realtime_band_data.forEach(i => {

                if( document.getElementById("realtime_channel").value == i['channel']){
                    document.getElementById("realtime_ch_bandwidth").value = i['sample_rate']/1e6
                }

            });
        }

        get_realtime_config()
        chart.onSeriesBackgroundMouseDoubleClick((_, event) => {

            if(active_channel.slice(0,-1) != "REPLAY"){
                const locationAxis = chart.translateCoordinate(event, chart.coordsAxis)

            //  console.log(locationAxis.x,"==========>>>>>>>>>>")
                document.getElementById("frequency").value = (locationAxis.x).toFixed(3);
                document.getElementById("unit").value = "mhz"
                // showPopup();
                // document.getElementById('openwebrx-dialog-bookmark').style.display = "block";
                get_realtime_config()
                check_active_channel()
                // get_bookmark_data()
            }
        })

        series.onMouseDoubleClick((_, event) => {
            if(active_channel.slice(0,-1) != "REPLAY"){
                const locationAxis = chart.translateCoordinate(event, chart.coordsAxis)

            //  console.log(locationAxis.x,"==========>>>>>>>>>>")
                document.getElementById("frequency").value = (locationAxis.x).toFixed(3);
                document.getElementById("unit").value = "mhz"
                get_realtime_config()
                check_active_channel()
                // showPopup();
                // document.getElementById('openwebrx-dialog-bookmark').style.display = "block";

                // get_realtime_config()
                // get_bookmark_data()
            }
        })




        function add_realtime_sweep_band(){
             if(spectrum_data.hasOwnProperty('realtime_data')){
                // console.log("in realtimne band fn", spectrum_data['realtime_data'])
                spectrum_data['realtime_data'].forEach(i => {
                    if( i['start_frequency']/1e6  >= start_freq && i['stop_frequency']/1e6 <= stop_freq && i['realtime_port']['status'] == 'active'){
                        // console.log(i,i['realtime_port']['port'])
                        addRealtimeBand(i['start_frequency']/1e6,i['stop_frequency']/1e6,parseFloat(i['bandwidth']/1e6),i['channel'],"#9fa86d", i['realtime_port']['port'])
                    }
                    else{
                        console.log("Hello")
                        realtime_ws_config[i['channel']] =  {'mode': "realtime" , 'port' : i['realtime_port']['port'].toString(),  "ws_obj" : null}
                    }
                });

            }
        }





        function showPopup() {
            document.getElementById("openwebrx-dialog-bookmark").style.display = "block";
        }

        window.onclick = function (event) {
            if (event.target == document.getElementById("openwebrx-dialog-bookmark")) {
                document.getElementById("openwebrx-dialog-bookmark").style.display = "none";
            }
        }

        window.onclick = function (event) {
            var modal = document.getElementById("openwebrx-dialog-bookmark");
            if (event.target != modal) {
                // hidePopup();
            }
        }


        function set_min_max_amp(min, max) {

            chart.getDefaultAxisY().setInterval({ start: min, end: max }).setDefaultInterval({ start: min, end: max })

        }

        function update_realtime_center_frerquency(fre_val,bandwidth,name){
            console.log("CENTER FREQ UPDATE ", fre_val , bandwidth)
            var total = parseInt(fre_val * 1e6)
            var samp_rate = bandwidth * 1e6
            json_data = {
            "center_frequency": total,
            "sample_rate": parseFloat(samp_rate),
            "start_frequency": total - samp_rate / 2,
            "stop_frequency": total + samp_rate / 2,
            "channel": name,
            "mode": "realtime"
            }
            $.ajax({
                type: 'POST',
                url: '/update_center_freq',
                data: JSON.stringify(json_data),
                contentType: 'application/json',
                success: function (data) {
                    console.log(json_data)
                setTimeout(function(){
                     if (realtime_ws_config[name]['ws_obj']) {
                        realtime_ws_config[name]['ws_obj'].send(JSON.stringify({
                            'status': 'parameters',
                            'payload': {'center_frequency' : total}
                        }));
                    }
                },500)
                
                }
            });
        }


        function get_bookmark_data() {


            var fre_val = parseFloat(document.getElementById("frequency").value)*unit_conversion[document.getElementById("unit").value]
            var bandwidth = parseFloat(document.getElementById("realtime_ch_bandwidth").value)
            var unit = document.getElementById("unit").value
            var channel = active_channel
            var name = document.getElementById("realtime_channel").value

            // if (unit != "ghz") {
            //     fre_val = (fre_val * unit_conversion[unit])
            // } else {
            //     fre_val *= 1e9
            // }
            fre_val = fre_val / 1e6
                if(!xAxisBand[name]){
                    // console.log(name,realtime_ws_config)
                    addRealtimeBand((fre_val-bandwidth/2),(fre_val+bandwidth/2),parseFloat(bandwidth),name,"#9fa86d",realtime_ws_config[name]['port'])
                    document.getElementById('openwebrx-dialog-bookmark').style.display = "none";

                }
                else{
                    update_sweep_band((fre_val-bandwidth/2),(fre_val+bandwidth/2),bandwidth,name)
                }

            
            // update_monitoring_frequency(((fre_val-bandwidth/2) + (fre_val+bandwidth/2)) / 2,name)
           
           
            update_realtime_center_frerquency(fre_val,bandwidth,name)


        }


        const yAxis = chart.getDefaultAxisY()

        const threshold = yAxis.addConstantLine()
        threshold.setStrokeStyle(new SolidLine({
            thickness: 1,
            fillStyle: new SolidFill({ color: ColorHEX(threshold_color) })
        }))



        const threshold1 = yAxis
        .addCustomTick(UIElementBuilders.PointableTextBox)
        .setMouseInteractions(true)
        // .setAllocatesAxisSpace(true)
        .setTickLabelPadding(1)
        .setTextFormatter(
          (value) => "Threshold"
        );
        threshold1.setGridStrokeStyle(
            new SolidLine({
                thickness: 0,
                fillStyle: new SolidFill({ color: ColorHEX(threshold_color) }),
                // pattern: StipplePatterns.Dashed,
                patternScale: 4,
            }),
        )

        threshold.onMouseDrag((_,event) => {
            const locationAxis = chart.translateCoordinate(event,chart.coordsAxis)
            const displayTimeNew = locationAxis.y;
            threshold1.setValue(threshold.getValue())
            parent.document.getElementById('threshold').value = threshold.getValue().toFixed(0)
        })
        threshold1.getMarker().onMouseDrag((_,event) => {
            const locationAxis = chart.translateCoordinate(event,chart.coordsAxis)
            const displayTimeNew = locationAxis.y;
            threshold1.setValue(parseInt(displayTimeNew))
            threshold.setValue(parseInt(displayTimeNew))
            parent.document.getElementById('threshold').value = threshold.getValue().toFixed(0)

        })

        function set_threshold(upd_threshold) {
            // threshold.dispose()
            threshold.setValue(upd_threshold)
            threshold1.setValue(upd_threshold)
            window.parent.document.getElementById('threshold').value = (upd_threshold)
            const yPalette = new PalettedFill({
                lookUpProperty: 'y',
                lut: new LUT({
                    interpolate: false,
                    steps: [
                        { value: -20, color: ColorRGBA(60, 179, 113) },//green
                        { value: Math.round(upd_threshold ), color: ColorRGBA(255, 69, 0) },//red
                        { value: -150, color: ColorHEX('#FFFF00') },//green
                    ],
                }),
            })
            // ele = window.parent.document.getElementById('threshold')
            // parent.get_all_data(ele)
        }


        ele = window.parent.document.getElementById('threshold')
        parent.get_all_data(ele)


        threshold.onMouseDragStop((_, event, Value) => {

            window.parent.document.getElementById('threshold').value = parseInt(threshold.getValue())
            parent.set_threshold(parseInt(threshold.getValue()))
            window.parent.update_parameters({ 'threshold': parseInt(threshold.getValue()) })
        })

        threshold1.getMarker().onMouseDragStop((_, event, Value) => {

            window.parent.document.getElementById('threshold').value = parseInt(threshold.getValue())
            parent.set_threshold(parseInt(threshold.getValue()))
            window.parent.update_parameters({ 'threshold': parseInt(threshold.getValue()) })
        })
        const yPalette = new PalettedFill({
            lookUpProperty: 'y',
            lut: new LUT({
                interpolate: false,
                steps: [
                    { value: -20, color: ColorRGBA(60, 179, 113) },//green
                    { value: Math.round(threshold.getValue()), color: ColorRGBA(255, 69, 0) },//red
                    { value: -150, color: ColorHEX('#FFFF00') },//green
                ],
            }),
        })


        threshold.onTouchMove((_, event, Value) => {

            window.parent.document.getElementById('threshold').value = Math.round(threshold.getValue())

            ele = window.parent.document.getElementById('threshold')

            threshold1.setValue(threshold.getValue())

            parent.get_all_data(ele)

            })

        var realtime_ws_config = {};
        function addRealtimeBand(freq_start,freq_stop, size, channel, colorhex, port) {
            // console.log(port)
            realtime_ws_config[channel] =  {'mode': "realtime" , 'port' : port.toString(),  "ws_obj" : null}
            var name = channel
            var colorPicker = "white"
            var colorPicker1 = "white"
            var bname = name
            var xAxis = chart.getDefaultAxisX();
            const wxAxis = waterFall.getDefaultAxisX();
            var color = hexToRgb(colorhex)

            band_meta[name] = {'start_freq' : freq_start  , 'stop_freq' : freq_stop , 'band_bw' : (freq_stop - freq_start).toFixed(3) }

            bandLine[name] = xAxis.addConstantLine()
            bandLine[name].setMouseInteractions(false).setVisible(false)
            bandLine[name].setValue((freq_start+freq_stop)/2)

            wBandLine[name] = wxAxis.addConstantLine()
            wBandLine[name].setMouseInteractions(false).setVisible(false)
            wBandLine[name].setValue((freq_start+freq_stop)/2)


            xAxisBand[name] = xAxis.addBand();
            xAxisBand[name].setValueStart(freq_start).setValueEnd(freq_stop).setName(bname)

            xAxisBand[name].setFillStyle(new SolidFill({ color: ColorRGBA(color.r, color.g, color.b, 100) }));
            xAxisBand[name].setStrokeStyle(new SolidLine({
                thickness: 1,
                fillStyle: new SolidFill({ color: ColorHEX("#05183dff") })
            }));


            // ======================== waterfall ========================
            wxAxisBand[name] = wxAxis.addBand();
            wxAxisBand[name].setValueStart(freq_start).setValueEnd(freq_stop).setName(bname)
            wxAxisBand[name].setFillStyle(new SolidFill({ color: ColorRGBA(color.r, color.g, color.b, 100) }));
            wxAxisBand[name].setStrokeStyle(new SolidLine({
                thickness: 1,
                fillStyle: new SolidFill({ color: ColorHEX("#05183dff") })
            }));

            // =============== drag function =================
          // console.log(xAxisBand.getValueStart(),wxAxisBand.getValueStart())
          // console.log(xAxisBand.getValueEnd(),wxAxisBand.getValueEnd())
            xAxisBand[name].onMouseDrag((_, event, ValueEnd, ValueStart) => {

                const locationAxis = chart.translateCoordinate(event, chart.coordsAxis)
                wxAxisBand[name].setValueStart(xAxisBand[name].getValueStart()).setValueEnd(xAxisBand[name].getValueEnd())
                bandLine[name].setValue((xAxisBand[name].getValueStart()+xAxisBand[name].getValueEnd())/2)
                wBandLine[name].setValue((xAxisBand[name].getValueStart()+xAxisBand[name].getValueEnd())/2)
            });

            wxAxisBand[name].onMouseDrag((_, event, ValueEnd, ValueStart) => {

                const locationAxis = chart.translateCoordinate(event, chart.coordsAxis)
                xAxisBand[name].setValueStart(wxAxisBand[name].getValueStart()).setValueEnd(wxAxisBand[name].getValueEnd())
                bandLine[name].setValue((wxAxisBand[name].getValueStart()+wxAxisBand[name].getValueEnd())/2)
                wBandLine[name].setValue((wxAxisBand[name].getValueStart()+wxAxisBand[name].getValueEnd())/2)
            });


            // console.log(data)
            // if(data.realtime_data.realtime_port.status == 'active'){


            realtime_iq_data(name)

            // }
            xAxisBand[name].onMouseDragStop((_, event, ValueEnd, ValueStart) => {
                // console.log((xAxisBand.getValueEnd() - xAxisBand.getValueStart()).toFixed(3) , band_meta.band_bw )
                if((xAxisBand[name].getValueEnd() - xAxisBand[name].getValueStart()).toFixed(3)  != band_meta[name].band_bw){
                    xAxisBand[name].setValueStart(band_meta[name].start_freq).setValueEnd(band_meta[name].stop_freq)
                    wxAxisBand[name].setValueStart(band_meta[name].start_freq).setValueEnd(band_meta[name].stop_freq)
                    bandLine[name].setValue((band_meta[name].start_freq+band_meta[name].stop_freq)/2)
                    wBandLine[name].setValue((band_meta[name].start_freq+band_meta[name].stop_freq)/2)
                }
                else{

                    const locationAxis = chart.translateCoordinate(event, chart.coordsAxis)
                    wxAxisBand[name].setValueStart(xAxisBand[name].getValueStart()).setValueEnd(xAxisBand[name].getValueEnd())
                    bandLine[name].setValue((xAxisBand[name].getValueStart()+xAxisBand[name].getValueEnd())/2)
                    wBandLine[name].setValue((xAxisBand[name].getValueStart()+xAxisBand[name].getValueEnd())/2)
                    var bandwidth = parseInt(document.getElementById("realtime_ch_bandwidth").value)
                    var center_frequency = ((wxAxisBand[name].getValueEnd() + wxAxisBand[name].getValueStart()) / 2) 
                    update_realtime_center_frerquency(center_frequency,bandwidth,name)

                    band_meta[name] = {'start_freq' : wxAxisBand[name].getValueStart()  , 'stop_freq' : wxAxisBand[name].getValueEnd() , 'band_bw' : (freq_stop - freq_start).toFixed(3) }

                }

            });



            wxAxisBand[name].onMouseDragStop((_, event, ValueEnd, ValueStart) => {
                // realtime_iq_data()
                if((xAxisBand[name].getValueEnd() - xAxisBand[name].getValueStart()).toFixed(3) != band_meta[name]['band_bw']){
                    xAxisBand[name].setValueStart(band_meta[name].start_freq).setValueEnd(band_meta[name].stop_freq)
                    wxAxisBand[name].setValueStart(band_meta[name].start_freq).setValueEnd(band_meta[name].stop_freq)
                    bandLine[name].setValue((band_meta[name].start_freq+band_meta[name].stop_freq)/2)
                    wBandLine[name].setValue((band_meta[name].start_freq+band_meta[name].stop_freq)/2)
                }
                else{
                    const locationAxis = chart.translateCoordinate(event, chart.coordsAxis)
                    xAxisBand[name].setValueStart(wxAxisBand[name].getValueStart()).setValueEnd(wxAxisBand[name].getValueEnd())
                    bandLine[name].setValue((wxAxisBand[name].getValueStart()+wxAxisBand[name].getValueEnd())/2)
                    wBandLine[name].setValue((wxAxisBand[name].getValueStart()+wxAxisBand[name].getValueEnd())/2)

                    // console.log("Bandwidth",document.getElementById("realtime_ch_bandwidth").value)
                    var bandwidth = parseInt(document.getElementById("realtime_ch_bandwidth").value)
                    var center_frequency = ((wxAxisBand[name].getValueEnd() + wxAxisBand[name].getValueStart()) / 2)
                    update_realtime_center_frerquency(center_frequency,bandwidth,name)

                    band_meta[name] = {'start_freq' : wxAxisBand[name].getValueStart()  , 'stop_freq' : wxAxisBand[name].getValueEnd() , 'band_bw' : freq_stop - freq_start }
                   
                }

            });

            xAxisBand[name].onMouseDoubleClick((_, event) => {
                const locationAxis = chart.translateCoordinate(event, chart.coordsAxis)

              // console.log(locationAxis.x,"==========>>>>>>>>>>")
                document.getElementById("frequency").value = ((xAxisBand[name].getValueStart()+xAxisBand[name].getValueEnd())/2).toFixed(3);

                document.getElementById("unit").value = "mhz"
                get_realtime_config()
                check_active_channel()


            })

            xAxisBand[name].onMouseEnter(()=>{
                if(wxAxisBand[name]){
                    wxAxisBand[name].setHighlight(true)
                }
                bandLine[name].setVisible(true)
                wBandLine[name].setVisible(true)
                // wxAxisBand[name].setHighlight(0.5)
            })
            wxAxisBand[name].onMouseEnter(()=>{
                if(xAxisBand[name]){
                    xAxisBand[name].setHighlight(true)
                }
                bandLine[name].setVisible(true)
                wBandLine[name].setVisible(true)
                // xAxisBand[name].setHighlight(0.5)
            })

            xAxisBand[name].onMouseLeave(()=>{
                bandLine[name].setVisible(false)
                wBandLine[name].setVisible(false)
                if(wxAxisBand[name]){
                    wxAxisBand[name].setHighlight(false)
                }
                // wxAxisBand[name].setHighlight(0.5)
            })

            wxAxisBand[name].onMouseLeave(()=>{
                if(xAxisBand[name]){
                    xAxisBand[name].setHighlight(false)
                }
                bandLine[name].setVisible(false)
                wBandLine[name].setVisible(false)
                // xAxisBand[uid].setHighlight(0.5)
            })




        }

        function update_sweep_band(bn_freq_start,bn_freq_stop,bandwidth,name){
          console.log("in update fn" ,bn_freq_start,bn_freq_stop,name,xAxisBand[name])
          if(xAxisBand[name] && wxAxisBand[name]){
            xAxisBand[name].setValueStart(bn_freq_start).setValueEnd(bn_freq_stop)
            wxAxisBand[name].setValueStart(bn_freq_start).setValueEnd(bn_freq_stop)
            bandLine[name].setValue((bn_freq_start+bn_freq_stop)/2)
            wBandLine[name].setValue((bn_freq_start+bn_freq_stop)/2)

          }
          else{
            port = spectrum_data['realtime_data']['realtime_port'][0]['port']
            addRealtimeBand(bn_freq_start,bn_freq_stop,bandwidth,name,"#9fa86d", port)
          }
            if(document.getElementById('openwebrx-dialog-bookmark').style.display == "block"){
                get_bookmark_data_clear()
            }
        }


        function addBand(freq, size, channel) {
          // console.log("in get add band,",freq,size,channel)
            const frequency = freq
            const bandsize = size
            const colorPicker = "white"
            const colorPicker1 = "white"

            const new_color = hexToRgb(colorPicker)
            const new_color1 = hexToRgb(colorPicker1)


            // ======================== spectrum ==========================
            const xAxis = chart.getDefaultAxisX();
            xAxisBand = xAxis.addBand();

            xAxisBand.setValueStart(freq + bandsize).setValueEnd(freq - bandsize).setName(channel)
            xAxisBand.setFillStyle(new SolidFill({ color: ColorRGBA(255, 255, 255, 30) }));
            xAxisBand.setStrokeStyle(new SolidLine({
                thickness: 1,
                fillStyle: new SolidFill({ color: ColorRGBA(255, 255, 255) })
            }));


            // ======================== waterfall ========================
            const wxAxis = waterFall.getDefaultAxisX();
            wxAxisBand = wxAxis.addBand();
            wxAxisBand.setValueStart(freq + bandsize).setValueEnd(freq - bandsize).setName(channel)
            wxAxisBand.setFillStyle(new SolidFill({ color: ColorRGBA(255, 255, 255, 30) }));
            wxAxisBand.setStrokeStyle(new SolidLine({
                thickness: 1,
                fillStyle: new SolidFill({ color: ColorRGBA(255, 255, 255) })
            }));


            // ================ constantLine ================


            get_bookmark_data_clear()

        }


        function delete_band() {

            wxAxisBand.dispose()
            xAxisBand.dispose()
            constantLine1.dispose()
            constantLine2.dispose()
            chart.addLegendBox().dispose()

        }


        function change_mod(val) {
            document.getElementById("modulation").value = val;
            document.getElementById("sample_rate_bm").value = banwidth_val_of_mode[document.getElementById("modulation").value]
            document.getElementById("name").value = val

        }

        // cursor style
        chart.setAutoCursor((cursor) => cursor
            .setGridStrokeXStyle(new SolidLine({ thickness: 1, fillStyle: new SolidFill({ color: ColorRGBA(255, 255, 255) }) }))
        )


        function change_mod(val) {
            document.getElementById("modulation").value = val;
            document.getElementById("sample_rate_bm").value = banwidth_val_of_mode[document.getElementById("modulation").value]
            document.getElementById("name").value = val
        }


        function check_active_channel() {
            $.ajax({
                type: 'GET',
                url: '/get_active_channels_realtime',
                contentType: 'application/json',
                success: function (data) {
                    console.log("data",data)
                    if (data.length == 0) {
                        var modal = document.getElementById("alert_ch_modal");
                        var close = document.getElementById("closeModal");

                        modal.style.display = "block";

                        setTimeout(function () { document.getElementById("alert_ch_modal").style.display = 'none' }, 4000);
                        close.addEventListener("click", function () {
                            modal.style.display = "none";
                        });
                        status1 = false
                    }
                    else {
                        // if (band_count_sweep < 1) {
                            document.getElementById('openwebrx-dialog-bookmark').style.display = "block";
                        //     band_count_sweep = band_count_sweep + 1
                        // }
                    }
                }
            })
        }


        // function update_monitoring_frequency(freq,name) {
        //   // console.log("in drag functin ",freq)
        //     $.ajax({
        //         type: 'GET',
        //         url: '/get_active_channels_realtime',
        //         contentType: 'application/json',
        //         success: function (data) {


        //             json_data = { "channel": name, "mode": "realtime" }

        //             $.ajax({
        //                 type: 'POST',
        //                 url: '/get_center_freq',
        //                 data: JSON.stringify(json_data),
        //                 contentType: 'application/json',
        //                 success: function (data) {

        //                     var update_data = {

        //                         "center_frequency": parseFloat((freq).toFixed(2))*1e6,
        //                         "sample_rate": parseFloat(data['sample_rate']),
        //                         "start_frequency": parseFloat((freq * 1e6) - (data['sample_rate'] / 2)),
        //                         "stop_frequency": parseFloat((freq * 1e6) + (data['sample_rate'] / 2)),
        //                         "channel": data['channel'],
        //                         "mode": "realtime"
        //                     }
        //                     $.ajax({
        //                         type: 'POST',
        //                         url: '/update_center_freq',
        //                         data: JSON.stringify(update_data),
        //                         contentType: 'application/json',
        //                         success: function (data) {


        //                         }
        //                     })
        //                 }
        //             })
        //         }
        //     })
        // }


        var legendBuilder,legend_backgrd;
        if(page_theme =='light'){
            legendBuilder = LegendBoxBuilders.HorizontalLegendBox.styleEntries((entry) => entry
            .setTextFillStyle(new SolidFill({ color: ColorHEX('#000000') }))
            .setLUTLength(200)
            )
            legend_backgrd = "#ffffffcf"

        }
        else{
            legendBuilder = LegendBoxBuilders.HorizontalLegendBox.styleEntries((entry) => entry
            .setTextFillStyle(new SolidFill({ color: ColorHEX('#FFFFFF') }))
            .setLUTLength(200)
            )
            legend_backgrd = "#00000061"

        }


        function min_hold_change() {

            if(window.parent.document.getElementById("min_hold_value").value == 0 || window.parent.document.getElementById("min_hold_value").value == '' ){
              window.parent.document.getElementById("min_hold_value").focus()
              window.parent.document.getElementById("min_hold_value").value= 5
            }else if(window.parent.document.getElementById("min_hold_value").value <= 300  && window.parent.document.getElementById("min_hold_value").value > 0 ){
                Minlevel = window.parent.document.getElementById("min_hold_value").value
                minCircular(Minlevel)
              
            }else{
                window.parent.document.getElementById("min_hold_value").focus()
                window.parent.document.getElementById("min_hold_value").value= 5
              // caPersistence = new CircularArray(parseInt(Persistencelevel));
              // Minlevel = window.parent.document.getElementById("min_hold_value").value
            }
        };

        function avg_hold_change() {
        
            // console.log("HI hold change")
            if(window.parent.document.getElementById("avg_input").value == 0 || window.parent.document.getElementById("avg_input").value == '' ){
                // console.log("HI hold change IF")
              window.parent.document.getElementById("avg_input").focus()
              window.parent.document.getElementById("avg_input").value= 5
            }else if(window.parent.document.getElementById("avg_input").value <= 300  && window.parent.document.getElementById("avg_input").value > 0 ){
                // console.log("HI hold change ELSE IF")
                  AverageLevel = window.parent.document.getElementById('avg_input').value;
              caAverage = new CircularArray(parseInt(AverageLevel));
              
            }else{
                console.log("HI hold change ELse")
                window.parent.document.getElementById("avg_input").focus()
                window.parent.document.getElementById("avg_input").value= 5
              // caPersistence = new CircularArray(parseInt(Persistencelevel));
              // Minlevel = window.parent.document.getElementById("min_hold_value").value
            }
          }

        
        function Persistence_hold_change() {
            if(window.parent.document.getElementById("Persistence_hold_value").value == '0' || window.parent.document.getElementById("Persistence_hold_value").value == '' ){
              window.parent.document.getElementById("Persistence_hold_value").focus()
              window.parent.document.getElementById("Persistence_hold_value").value= 5
            }else if(window.parent.document.getElementById("Persistence_hold_value").value <= 300  && window.parent.document.getElementById("Persistence_hold_value").value > 0 ){
                Persistencelevel = window.parent.document.getElementById("Persistence_hold_value").value
                PersistenceCircular(Persistencelevel)
              
            }else{
                window.parent.document.getElementById("Persistence_hold_value").focus()
                window.parent.document.getElementById("Persistence_hold_value").value= 5
              // caPersistence = new CircularArray(parseInt(Persistencelevel));
              // Minlevel = window.parent.document.getElementById("min_hold_value").value
            }
          };



        var legend2 = waterFall
            .addLegendBox(legendBuilder)
            .setTitle(false)
            .setPosition({ x: 97.5, y: 95.5 })

        legend2.setBackground((background) => background
            .setFillStyle(new SolidFill({ color: ColorHEX(legend_backgrd) }))
            .setStrokeStyle(new SolidLine({ thickness: 1, fillStyle: new SolidFill({ color: ColorHEX('#FFFFFF') }) }))
        )


        legend2.setDraggingMode(0)



        function reconfig_lut(){
            // console.log("Start",dataVal.y.length)
            array = dataVal.y
            var total = 0
            for(var i = 0; i < dataVal.y.length; i++) {
                total += dataVal.y[i];
            }
            var avg = total / dataVal.y.length;
            min_step_avg = parseInt(dataVal.y.reduce((a, b) => a + b) / dataVal.y.length);
            mid_step_avg = min_step_avg + 10
            max_step_avg = min_step_avg + 20
            console.log("Start",(parent.document.getElementById('waterfall_theme').value).slice(0,-2))
            if(((parent.document.getElementById('waterfall_theme').value).slice(0,-2)) == "preset"){
                // console.log("preset")
                lut = new LUT({
                    // steps: regularColorSteps(-20, -120, theme.examples.spectrogramColorPalette),
                    steps: [
                        // { value: 0 , color: ColorHEX("#00000000") },//green
                        { value: parseInt(parent.document.getElementById('min_step_theme').value), color: ColorHEX(parent.document.getElementById("b_color3").value) },//green
                        { value: parseInt(parent.document.getElementById('mid_step_theme').value), color: ColorHEX(parent.document.getElementById("b_color2").value) },//red
                        { value: parseInt(parent.document.getElementById('max_step_theme').value), color: ColorHEX(parent.document.getElementById("b_color1").value) },//green
                    ],
                    units: 'dBm',
                    interpolate: true,
                })
            }
            else if(parent.document.getElementById('waterfall_theme').value == "theme_1" || parent.document.getElementById('waterfall_theme').value == "theme_3"){
                lut = new LUT({
                    // steps: regularColorSteps(-20, -120, theme.examples.spectrogramColorPalette),
                    steps: [
                        // { value: 0, color: ColorHEX("#00000000") },
                        { value: min_step_avg + 25, color: ColorHEX(parent.max_step) },
                        { value: min_step_avg + 15, color: ColorHEX(parent.mid_step1) },
                        { value: min_step_avg + 10 , color: ColorHEX(parent.mid_step2) },
                        { value: min_step_avg , color: ColorHEX(parent.min_step) },
                    ],
                    units: 'dBm',
                    interpolate: true,
                })
            }
           else if(parent.document.getElementById('waterfall_theme').value == "theme_2"){

                lut = new LUT({
                    // steps: regularColorSteps(-20, -120, theme.examples.spectrogramColorPalette),
                    steps: [
                        // { value: 0, color: ColorHEX("#00000000") },//blue
                        { value: max_step_avg, color: ColorHEX(parent.max_step) },//green
                        { value: mid_step_avg, color: ColorHEX(parent.mid_step1) },//red
                        { value: min_step_avg, color: ColorHEX(parent.min_step) },//green
                    ],
                    units: 'dBm',
                    interpolate: true,
                })
            }
            else {

                lut = new LUT({
                    // steps: regularColorSteps(-20, -120, theme.examples.spectrogramColorPalette),
                    steps: [
                        // { value: 0, color: ColorHEX("#00000000") },//blue
                        { value: parseInt(parent.max_step_val), color: ColorHEX(parent.max_step) },//green
                        { value: parseInt(parent.mid_step_val), color: ColorHEX(parent.mid_step1) },//red
                        { value: parseInt(parent.min_step_val), color: ColorHEX(parent.min_step) },//green
                    ],
                    units: 'dBm',
                    interpolate: true,
                })
            }

            paletteFill = new PalettedFill({ lut, lookUpProperty: 'value' })
            heatmapSeries
            .setFillStyle(paletteFill)

            if(legend2){
                legend2.dispose()
            }
            legend2 = waterFall
                .addLegendBox(legendBuilder)
                .setTitle(false)
                .setPosition({ x: 97.5, y: 95.5 })

            legend2.setBackground((background) => background
                .setFillStyle(new SolidFill({ color: ColorHEX(legend_backgrd) }))
                .setStrokeStyle(new SolidLine({ thickness: 1, fillStyle: new SolidFill({ color: ColorHEX('#FFFFFF') }) }))
            )
            legend2.add(heatmapSeries, { toggleVisibilityOnClick: false })
            legend2.setDraggingMode(0)
            // console.log("End")
            
        }




        function delete_band() {
            wxAxisBand.dispose()
            xAxisBand.dispose()
            constantLine1.dispose()
            constantLine2.dispose()
            chart.addLegendBox().dispose()

        }


        function change_mod(val) {
            document.getElementById("modulation").value = val;
            document.getElementById("sample_rate_bm").value = banwidth_val_of_mode[document.getElementById("modulation").value]
            document.getElementById("name").value = val

        }


        // cursor style
        chart.setAutoCursor((cursor) => cursor
            .setGridStrokeXStyle(new SolidLine({ thickness: 1, fillStyle: new SolidFill({ color: ColorRGBA(255, 255, 255) }) }))
        )


        function change_mod(val) {
            document.getElementById("modulation").value = val;
            document.getElementById("sample_rate_bm").value = banwidth_val_of_mode[document.getElementById("modulation").value]
            document.getElementById("name").value = val

        }


        // ======================================================================================================
        peak_btn_parent = window.parent.document.getElementById('hide_peak')
        if (peak_btn_parent.checked) {
            peak_data_flag = true
        }

        auto_threshold_btn = window.parent.document.getElementById('auto_threshold')
        if (auto_threshold_btn.checked) {
            auto_threshold_flag = true
        }

        auto_axis_btn = window.parent.document.getElementById('auto_y_axis')
        if (auto_axis_btn.checked) {
            auto_Y_axis_flag = true
        }


        // ##########################################################################

        //----------------------- data source -------------------------


        const minValues = new Array(dataSampleSize_1).fill(Infinity)
        const maxValues = new Array(dataSampleSize_1).fill(-Infinity)
        const avgValues = new Array(dataSampleSize_1).fill(Infinity)

        function getAverage(array) {
            let sum = 0;
            for (let i = 0; i < array.length; i++) {
                sum += array[i];
            }
            return sum / array.length;
        }


        function reset_holds() {
            minValues.fill(Infinity)
            maxValues.fill(-Infinity)
            avgValues.fill(0)

        }


        function show_traces_max() {
            // console.log("in max show traces")
            var checkBox_max = document.getElementById("max_hold");
            if (checkBox_max.checked == true) {
                button_click_max = true
                update_traces_settings()

            } else {
                button_click_max = false
                maxValues.fill(-Infinity)
                maxSeries.clear()
                update_traces_settings()
            }
        }


        function show_traces_min() {
            // console.log("in min show traces")
            var checkBox_min = document.getElementById("min_hold");
            if (checkBox_min.checked == true) {
                button_click_min = true
                update_traces_settings()

            }
            else {
                button_click_min = false
                minValues.fill(Infinity)
                minSeries.clear()
                update_traces_settings()

            }
        }


        function show_traces_avg() {
            // console.log("in avg show traces")
            var checkBox_avg = document.getElementById("avg_hold");
            if (checkBox_avg.checked == true) {
                button_click_avg = true
                update_traces_settings()

            }
            else {

                button_click_avg = false
                avgValues.fill(0)
                avgSeries.clear()
                update_traces_settings()

            }

        }

        function show_traces_persis() {
            var checkBox_persis = document.getElementById("persistence_data_btn");
            if (checkBox_persis.checked == true) {
                button_click_persistence = true
                update_traces_settings()

            } else {
                persistenceSeries.clear()
                button_click_persistence = false
                update_traces_settings()
            }
        }


        function show_traces() {
            checkBox_Showtraces = document.getElementById('show_traces')
            if (checkBox_Showtraces.checked == true) {
                button_click_showtraces = true
            }
            else {
                button_click_showtraces = false
                maxValues.fill(-Infinity)
                maxSeries.clear()
                minValues.fill(Infinity)
                minSeries.clear()
                avgValues.fill(0)
                avgSeries.clear()
            }
        }


        function show_peak_data() {
            var checkBox_peak = document.getElementById("peak_data_btn");
            if (checkBox_peak.checked == false) {
                peak_data_flag = false
                update_traces_settings()
            }
            else {
                peak_data_flag = true
                seriespeak.clear()
                update_traces_settings()
            }

        }


        function show_mark_data() {
            var checkBox_mark = document.getElementById("mark_data_btn");
            if (checkBox_mark.checked == false) {
                mark_data_flag = false
                set_marked_positions()

            }
            else {
                mark_data_flag = true
                set_marked_positions()

            }
        }


        function show_main_curve() {
            var checkBox_main = document.getElementById("main_curve");
            if (checkBox_main.checked == true) {
                button_click_main = true
                update_traces_settings()

            }
            else {
                button_click_main = false
                series.clear()
                update_traces_settings()

            }
        }


        function show_traces_band() {
            console.log("in max show traces")
            var checkBox_band = document.getElementById("band");
            if (checkBox_band.checked == true) {
                button_click_band = true
                update_traces_settings()

            } else {
                button_click_band = false
                update_traces_settings()
            }
        }


        function update_traces_settings() {
            traces_json = { active_channel : active_channel,active_mode : active_mode,"button_click_max": button_click_max, "button_click_min": button_click_min, "button_click_avg": button_click_avg, "button_click_main": button_click_main,"enable_marker" : mark_data_flag ,"enable_peak" : peak_data_flag,"enable_band":button_click_band,
                "persistence_trace":button_click_persistence,
            }
            $.ajax({
                type: 'POST',
                url: '/update_show_traces_settings ',
                data: JSON.stringify(traces_json),
                contentType: 'application/json',
                success: function (data) {
                    traces_setting()
                }
            })
        }


        function traces_setting() {

            $.ajax({
                type: 'POST',
                url: '/get_show_traces_settings',
                data: JSON.stringify({ active_channel : active_channel,active_mode : active_mode }),
                contentType: 'application/json',
                success: function (data) {
                    console.log(data)
                    button_click_max = data['button_click_max']
                    button_click_min = data['button_click_min']
                    button_click_avg = data['button_click_avg']
                    button_click_main = data['button_click_main']
                    mark_data_flag = data['enable_marker']
                    peak_data_flag = data["enable_peak"]
                    button_click_band = data['enable_band']
                    button_click_persistence = data['persistence_trace']

                    if (button_click_max == true) {
                        document.getElementById("max_hold").checked = true
                    }
                    else {

                        document.getElementById("max_hold").checked = false
                    }

                    if (button_click_min == true) {
                        document.getElementById("min_hold").checked = true
                    }
                    else {

                        document.getElementById("min_hold").checked = false
                    }

                    if (button_click_avg == true) {
                        document.getElementById("avg_hold").checked = true
                    }
                    else {

                        document.getElementById("avg_hold").checked = false
                    }

                    if (button_click_main == true) {
                        document.getElementById("main_curve").checked = true
                    }
                    else {

                        document.getElementById("main_curve").checked = false
                    }
                    if (mark_data_flag == true) {
                        document.getElementById("mark_data_btn").checked = true
                        set_marked_positions()
                    }
                    else {
                        set_marked_positions()
                        document.getElementById("mark_data_btn").checked = false
                    }
                    if (peak_data_flag == true) {
                        document.getElementById("peak_data_btn").checked = true

                    }
                    else {

                        document.getElementById("peak_data_btn").checked = false
                    }
                     if (button_click_persistence == true) {
                        document.getElementById("persistence_data_btn").checked = true
                        
                    }
                    else {

                        document.getElementById("persistence_data_btn").checked = false
                    }
                    if (button_click_band == true) {
                        document.getElementById("band").checked = true
                        
                    }
                    else {

                        document.getElementById("band").checked = false
                    }
                }
            });
        }



        // ----------------------------------- ScreenShot Btn ------------------------------------

        document.getElementById('screenshot_img').onclick = function () {
            chart.saveToFile('Spectrum_screenshot')
        }

        document.getElementById('csv_export').onclick = function () {
            var rows = [
                [
                    "Frequency(MHz)",
                    "Power(dBm)"
                ],
                ...dataVal.x.map((x, i) => ([(dataVal.x[i] * 1e-6).toFixed(3), dataVal.y[i].toFixed(1)]))]
                .map(e => e.join(","))
                .join("\n");
            let csvContent = "data:text/csv;charset=utf-8,"
                + rows;
            var encodedUri = encodeURI(csvContent);
            window.open(encodedUri);
        }

        // cursor style
        chart.setAutoCursor((cursor) => cursor
            .setGridStrokeXStyle(new DashedLine({ thickness: 1, fillStyle: new SolidFill({ color: ColorHEX(theme_color) }) }))
            .setGridStrokeYStyle(new DashedLine({ thickness: 1, fillStyle: new SolidFill({ color: ColorHEX(theme_color) }) }))
            .setGridStrokeXCut(true).setGridStrokeYCut(true)
        )

        // =================================  Series Hold Starts  ===========================================
       
        var Persistence_cycles = window.parent.document.getElementById('Persistence_hold_value').value;
        var avg_max_cycle = window.parent.document.getElementById('avg_input').value;
        var AverageLevel = window.parent.document.getElementById('avg_input').value;


        window.parent.document.getElementById("Persistence_hold_value").addEventListener("keypress", function (event) {
            if (event.key === "Enter") {
                Persistence_hold_change()
            }
        });
        
        window.parent.document.getElementById("avg_input").addEventListener("keypress", function (event) {
            if (event.key === "Enter") {
                avg_hold_change()
            }
        });
        
        window.parent.document.getElementById("min_hold_value").addEventListener("keypress", function (event) {
            if (event.key === "Enter") {
                min_hold_change()
            }
        });

          





        //   window.parent.document.getElementById("min_hold_value").oninput = avg_hold_change()

          

        // document.getElementById('set_avg_cycle').onclick= function(){
          
        // }

        function CircularArray(PersistenceLength) {
            this.PersistenceLength = PersistenceLength;
            // console.log("Persistence length:::::::",this.PersistenceLength)
          }

          CircularArray.prototype = Object.create(Array.prototype);

          CircularArray.prototype.push = function(element) {
            Array.prototype.push.call(this, element);
            while (this.length > this.PersistenceLength) {
              // console.log("Persistence length:::::::",this.PersistenceLength)
                this.shift();
              }
          }



          function getCol(matrix, col){
                var column = [];
                for(var i=0; i<matrix.length; i++){
                    column.push(matrix[i][col]);
                }
                return column; // return column data..
          }
          
         
          function PersistenceCircular(number){
              caPersistence = new CircularArray(number)
          }
          function get_Persistence_hold(){
              // console.log("HI")
            
              var store = [];
                  
                  for(var j=0;j<caPersistence[0].length;j++){
                      var index = getCol(caPersistence, j);
                      store.push(Math.max(...index));       
              }
              return store;
          }
          

          function minCircular(number){
              caMin = new CircularArray(number)
          }


          function get_min_hold(){
              var store = [];
                  
                  for(var j=0;j<caMin[0].length;j++){
                      var index = getCol(caMin, j);
                      store.push(Math.min(...index));       
              }
              return store;
          }

          var caAverage = new CircularArray(parseInt(AverageLevel));


        //   window.parent.document.getElementById('avg_input').oninput = function() {
        //     if(window.parent.document.getElementById('avg_input').value>0){
        //       AverageLevel = window.parent.document.getElementById('avg_input').value;
        //       caAverage = new CircularArray(parseInt(AverageLevel));
        //     //   console.log('AverageLevel',AverageLevel)
        //       // ws.send(JSON.stringify({ status: "setting", average_counter:parseInt(avg_max_cycle)}));
        //     }
        //     else{
        //       window.parent.document.getElementById('avg_input').value = ''
        //       document.getElementById('avg_input').focus()
              
        //     }
        //   }

          const average = (...args) => args.reduce((a, b) => a + b) / args.length;  



        function AverageCircular(number){
            caAverage = new CircularArray(number);
        }


        function get_Average_data(){
            var store = [];
                
                for(var j=0;j<caAverage[0].length;j++){
                    var index = getCol(caAverage, j);
                    store.push(average(...index));       
            }
            return store;
        }
       
        var caMaincurve = new CircularArray(parseInt(5));
        function get_maincurve_data(){
            var store = [];
                
                for(var j=0;j<caMaincurve[0].length;j++){
                    var index = getCol(caMaincurve, j);
                    store.push(average(...index));       
            }
            return store;
        }
       
        function set_y_axis(){

            start_y = parseInt(window.parent.document.getElementById('minY').value)
            stop_y = parseInt(window.parent.document.getElementById('maxY').value)
            set_min_max_amp(start_y, stop_y)
    
        }
               
        // =================================   Series Hold End  ===========================================


        var wf_init = true,iSample;
        var Persistencelevel =  window.parent.document.getElementById("Persistence_hold_value").value
        var Minlevel =  window.parent.document.getElementById("min_hold_value").value
        var caMin = new CircularArray(parseInt(Minlevel));
        var caPersistence = new CircularArray(parseInt(Persistencelevel));
        var cnt = 0
       
        function websocket_data(evt) {
            dataVal = evt
            // console.log("DATA TEST :: ", dataVal)
            // cnt += 1
            // console.log(cnt)
            if(wf_init && dataVal.x.length > 0){

                wf_init = false
                close_loader()

                add_realtime_sweep_band()
              console.log(" sp wf updated the sample")
                sample_length = dataVal.x.length
              console.log("updated the sample", dataVal.x.length)
                // heatmapSeries.dispose()
                heatmapSeries = waterFall
                    .addHeatmapScrollingGridSeries({
                        scrollDimension: 'rows',
                        resolution: dataVal.x.length,
                        start: { x: start_freq, y: 0 },
                        step: { x: (stop_freq - start_freq) / (dataVal.x.length), y: heatmapMinTimeStepMs },

                    })
                    .setFillStyle(paletteFill)
                    .setWireframeStyle(emptyLine)
                    .setName("waterfall")
                    // Configure automatic data cleaning.
                    // .setDataCleaning({
                    //     // Out of view data can be lazily removed as long as total columns count remains over 1000.
                    //     minDataPointCount: 10,
                    // })

                reconfig_lut()

                // legend2.add(heatmapSeries, { toggleVisibilityOnClick: false })

                // heatmapSeries.setDataCleaning({ minDataPointCount: 1 })

            }
            // console.log("avg:",get_persistence_data())
            // heatmapSeries.addIntensityValues([dataVal.y])

             caMaincurve.push(dataVal.y)    
            // console.log(get_persistence_data())
            heatmapSeries.addIntensityValues([get_maincurve_data()])

            if (peak_data_flag == true) {
                peak_count = dataVal.auto_data.length
                // parent.document.getElementById("number_peaks").innerHTML = "Peaks : -- " + peak_count
                updateSeriespeak(dataVal.auto_data);
                // console.log(dataVal.auto_data)
            }

            else {
                seriespeak.clear()
            }





            // waterfall
            // handleIncomingData(time_counter, dataVal.y)
            time_counter = time_counter + 1;

            if (auto_threshold_flag == true) {
                av_int = getAverage(dataVal.y)
                set_threshold(Math.round(av_int + 20))

            }


            if (button_click_main == true) {

                updateSeries(dataVal.x, dataVal.y);

            }

            //  =================== auto y axis =======================
            if (auto_Y_axis_flag == true) {

                chart.getDefaultAxisY().setDefaultInterval({ start: (Math.min(...dataVal.y)), end: Math.max(...dataVal.y) })
            }

            // else {

            //     start_y = parseInt(window.parent.document.getElementById('minY').value)
            //     stop_y = parseInt(window.parent.document.getElementById('maxY').value)
            //     set_min_max_amp(start_y, stop_y)

            // }


            if (button_click_band == true) {
                // console.log("Hi in if ",button_click_band)
                spectrum_data['realtime_data'].forEach(i => {
                    if (xAxisBand[i['channel']]) {
                        xAxisBand[i['channel']].setVisible(true)
                        wxAxisBand[i['channel']].setVisible(true)
                        // console.log("Hi",i['channel'])
                    }
                });
            }
            else {
                spectrum_data['realtime_data'].forEach(i => {
                    if (xAxisBand[i['channel']]) {
                        // console.log("Hi",i['channel'])
                        xAxisBand[i['channel']].setVisible(false)
                        wxAxisBand[i['channel']].setVisible(false)
                    }
                });

            }


                         //  ================== New Traces              =======================

            if (button_click_max == true ) {
                var x = []
                var y = []
                cycleData.push(dataVal);
                if (cycleData.length > Max_cycles) {
                    cycleData.shift()

                    for (const cycle of cycleData) {
                        for (let i = 0; i < cycle.y.length; i++) {
                            // minValues[i] = Math.min(minValues[i], cycle.y[i]);
                            maxValues[i] = Math.max(maxValues[i], cycle.y[i]);
                            // avgValues[i] += cycle.y[i] / Max_cycles;
                        }
                    }
                   
               
                // Old Series Plotting
                // if (button_click_min == true ){
                //     // console.log(dataVal.x, maxValues)
                // }
                    updateMax(dataVal.x, maxValues);
                    // console.log(dataVal.x, maxValues)
                
                    
                  }
                
            // maxValues.fill(0);

            }


            if(button_click_min == true){
                if(caMin){
                    // console.log("button_click_min")
                    caMin.push(dataVal.y)
                }
                updateMin(dataVal.x, get_min_hold());
            }

            if(button_click_avg == true){   
                caAverage.push(dataVal.y)
                updateAvg(dataVal.x, get_Average_data());
            }

            if(button_click_persistence == true){
                // console.log("button_click_persistence")
                if(caPersistence){
                    // console.log("button_click_persistence if")
                    caPersistence.push(dataVal.y)
                }
                // console.log("HI 1",caPersistence.length,)

                updatePersistence(dataVal.x, get_Persistence_hold());
            }
          
            if (button_click_max == false && button_click_min == false && button_click_avg == false) {
                // updateMax(dataVal.x, maxValues);var
                // console.log(x,y,"===========================")
                
                minValues.fill(Infinity)
                maxValues.fill(-Infinity)

            }




            //  ================== for traces =========================
            //  all truee
            // if (button_click_max == true && button_click_min == true && button_click_avg == true) {
            //   // console.log('all true')
            //     cycleData.push(dataVal);
            //     if (cycleData.length > Max_cycles) {
            //         cycleData.shift()

            //         for (const cycle of cycleData) {
            //             for (let i = 0; i < cycle.y.length; i++) {
            //                 minValues[i] = Math.min(minValues[i], cycle.y[i]);
            //                 maxValues[i] = Math.max(maxValues[i], cycle.y[i]);
            //                 avgValues[i] += cycle.y[i] / Max_cycles;
            //             }
            //         }
            //         cycleData = [];

            //         updateMax(dataVal.x, maxValues);
            //         updateMin(dataVal.x, minValues);
            //         // updateAvg(dataVal.x, avgValues);
            //         avgValues.fill(0);
            //     }
            //     // if(caMax){
            //     // caMax.push(dataVal.y)
            //     // }
            //     // if(caMin){
            //     //     caMin.push(dataVal.y)
            //     // }
            //     // caPersistence.push(dataVal.y)
            //     // updateMax(dataVal.x, get_max_hold());
            //     // updateMin(dataVal.x, get_min_hold());
            //     // updateAvg(dataVal.x, get_persistence_data());
            //     avgValues.fill(0);
            // }

            // // if max true
            // if (button_click_max == true && button_click_min == false && button_click_avg == false) {
            //     cycleData.push(dataVal);
            //     if (cycleData.length > Max_cycles) {
            //         cycleData.shift()

            //         for (const cycle of cycleData) {
            //             for (let i = 0; i < cycle.y.length; i++) {
            //                 maxValues[i] = Math.max(maxValues[i], cycle.y[i]);
            //             }
            //         }
            //         const allOnes = maxValues.every(value => value === 1);
            //         const allZeros = maxValues.every(value => value === 0);
            //         if (allOnes || allZeros) {

            //             maxValues.fill(-Infinity)
            //             maxSeries.clear()
            //         } else {
            //             updateMax(dataVal.x, maxValues);
            //             cycleData = [];
            //         }

            //     }
            //     // caMax.push(dataVal.y)
            //     // updateMax(dataVal.x, get_max_hold());
            // }
            // //  if max and min true
            // if (button_click_max == true && button_click_min == true && button_click_avg == false) {
            //     cycleData.push(dataVal);
            //     if (cycleData.length > Max_cycles) {
            //         cycleData.shift()
            //         for (const cycle of cycleData) {
            //             for (let i = 0; i < cycle.y.length; i++) {
            //                 minValues[i] = Math.min(minValues[i], cycle.y[i]);
            //                 maxValues[i] = Math.max(maxValues[i], cycle.y[i]);
            //                 minValues[i] = Math.min(minValues[i], cycle.y[i]);
            //             }
            //         }
            //         cycleData = [];
            //         updateMax(dataVal.x, maxValues);
            //         updateMin(dataVal.x, minValues);
            //     }

            //     // caMax.push(dataVal.y)
            //     // caMin.push(dataVal.y)
            //     // updateMax(dataVal.x, get_max_hold());
            //     // updateMin(dataVal.x, get_min_hold());
            // }
            // // if min and avg true
            // if (button_click_max == false && button_click_min == true && button_click_avg == true) {
            //     cycleData.push(dataVal);
            //     if (cycleData.length > Max_cycles) {
            //         cycleData.shift()
            //         for (const cycle of cycleData) {
            //             for (let i = 0; i < cycle.y.length; i++) {
            //                 minValues[i] = Math.min(minValues[i], cycle.y[i]);
            //                 // avgValues[i] += cycle.y[i] / Max_cycles;
            //             }
            //         }
            //         cycleData = [];
            //         // updateMin(dataVal.x, minValues);
            //         // updateAvg(dataVal.x, avgValues);
            //         avgValues.fill(0);

            //     }
            //     // caMin.push(dataVal.y)
            //     // updateMin(dataVal.x, get_min_hold());
            //     caPersistence.push(dataVal.y)
            //     updateAvg(dataVal.x, get_persistence_data());
            // }
            // // if min true
            // if (button_click_max == false && button_click_min == true && button_click_avg == false) {
            //     cycleData.push(dataVal);
            //     if (cycleData.length > Max_cycles) {
            //         cycleData.shift()

            //         for (const cycle of cycleData) {
            //             for (let i = 0; i < cycle.y.length; i++) {
            //                 minValues[i] = Math.min(minValues[i], cycle.y[i]);
            //             }
            //         }
            //         cycleData = [];
            //         updateMin(dataVal.x, minValues);

            //     }
            //     // caMin.push(dataVal.y)
            //     // updateMin(dataVal.x, get_min_hold());
            // }
            // // if avg true
            // if (button_click_max == false && button_click_min == false && button_click_avg == true) {
            //     // cycleData.push(dataVal);
            //     // if (cycleData.length > avg_max_cycle) {
            //     //     cycleData.shift()
            //     //     for (const cycle of cycleData) {
            //     //         for (let i = 0; i < cycle.y.length; i++) {
            //     //             avgValues[i] += cycle.y[i] / avg_max_cycle;
            //     //         }
            //     //     }
            //     //     cycleData = [];
            //     //     updateAvg(dataVal.x, avgValues);
            //     //     avgValues.fill(0);


            //     // }
            //     caPersistence.push(dataVal.y)
            //     updateAvg(dataVal.x, get_persistence_data());
            // }
            // // if max and avg true
            // if (button_click_max == true && button_click_min == false && button_click_avg == true) {
            //     cycleData.push(dataVal);
            //     if (cycleData.length > Max_cycles) {
            //         cycleData.shift()
            //         for (const cycle of cycleData) {
            //             for (let i = 0; i < cycle.y.length; i++) {
            //                 maxValues[i] = Math.max(maxValues[i], cycle.y[i]);
            //                 // avgValues[i] += cycle.y[i] / Max_cycles;
            //             }
            //         }
            //         cycleData = [];
            //         // updateAvg(dataVal.x, avgValues);
            //         updateMax(dataVal.x, maxValues);
            //         caPersistence.push(dataVal.y)
            //         updateAvg(dataVal.x, get_persistence_data());
            //         avgValues.fill(0);
            //     }
            //     // caMax.push(dataVal.y)
                
            //     // updateMax(dataVal.x,  get_max_hold());
            // }

            // else if (button_click_max == false && button_click_min == false && button_click_avg == false) {
            //     minValues.fill(Infinity)
            //     maxValues.fill(-Infinity)
            //     avgValues.fill(0)
            // }


            for (var i = 0; i <= chartMarker.length; i++) {

                if (mark_data_flag == true) {
                    for (var i = 0; i <= chartMarker.length; i++) {
                        if (chartMarker[i]) {

                            update_marker(i)
                        }

                    }
                }
            }
        }


        function addMarkernew(x, y) {
            i = counter
          // console.log(window.parent.removed_marker)
          if(document.getElementById("mark_data_btn").checked == true)
            {
                if (i <= 4) {
                    var color = '#FFFFFF';

                    if (page_theme == 'light') {
                        color = "#0000FF"
                    }

                    $.ajax({
                    type: 'GET',
                    url: '/set_marker_sweep',
                    contentType: 'application/json',
                    success: function (res) {
                        var index = res.map(function(f) { return f.frequency; }).indexOf(x);
                        var marker_data=0
                        for(var l=0; l< res.length; l++){
                            var index = res.map(function(f) { return f.frequency; }).indexOf(x);
                            if( (res.findIndex(p => p.frequency == x))==-1){
                                if (chartMarker[i]) {
                                    chartMarker[i].dispose()
                                }
                                if (window.parent.removed_marker.length > 0) {
                                    for (var j = 0; j < window.parent.removed_marker.length; j++) {
                                        i = parseInt(window.parent.removed_marker[j])
                                        window.parent.removed_marker.splice(j, 1)
                                        break;
                                    }
                                }
                                else {
                                    i = counter
                                }

                                // console.log('add new marker',(res.findIndex(p => p.frequency == x)))
                                chartMarker[i] = chart.addChartMarkerXY()
                                chartMarker[i].setPosition({ x: x, y: y })
                                chartMarker[i].setMouseInteractions(true)
                                chartMarker[i].setPointMarker(marker => marker.setShape(PointShape.Diamond).setSize({ x: 12, y: 12 }).setFillStyle(new SolidFill({ color: ColorHEX(`${marker_color}`) }))).setResultTableVisibility(UIVisibilityModes.always).setGridStrokeXCut(true).setGridStrokeYCut(true).setResultTable((table) => table.setContent([[`M ${i + 1}`]])).setGridStrokeXVisibility(UIVisibilityModes.always).setGridStrokeYVisibility(UIVisibilityModes.always).setTickMarkerXVisibility(UIVisibilityModes.always).setTickMarkerYVisibility(UIVisibilityModes.always).setGridStrokeXStyle(new DashedLine({ fillStyle: new SolidFill({ color: ColorHEX("#a639f9") }) })).setGridStrokeYStyle(new DashedLine({ fillStyle: new SolidFill({ color: ColorHEX("#a639f9") }) }))


                                data = chartMarker[i].getPosition()
                                var frequency
                                var power
                                var marker_name
                                var data1 = {
                                    frequency: data.x,
                                    power: data.y,
                                    'marker_index': i,
                                    color: color
                                }

                                $.ajax({
                                    type: 'POST',
                                    url: "/get_marker_sweep",
                                    data: JSON.stringify(data1),
                                    dataType: 'json',
                                    success: function (data) {
                                        parent.marked_positions_table()
                                        // set_marked_positions()
                                    },
                                    error: function (xhr, status, error) {
                                        console.error("Error :", error);
                                    },
                                });
                                counter = counter + 1
                                break;
                            }
                            else{
                                // console.log('dont add new marker',(res.findIndex(p => p.frequency == x)))
                                var tr = window.parent.document.getElementById(`table_row_${index}`)
                                highlight_fn(tr, 3);
                                break;
                            }
                        }
                    },
                        error: function (xhr, status, error) {
                            console.error("Error :", error);
                        },
                    });





                }
                else {
                    counter = 4
                    addMarkerAgain(x, y)
                }
            }

        }


        function highlight_fn(inputElement, times) {
            for (let i = 0; i < times; i++) {
                inputElement.style.background = 'red';
                // inputElement.style.transform = 'scale(1.15)'
                inputElement.classList.add('transition_cls');
                setTimeout(() => {
                inputElement.style.background = '';
                inputElement.style.transform = 'scale(1)'

                }, 200);
                setTimeout(() => {
                inputElement.style.background = 'red';
                // inputElement.style.transform = 'scale(1.15)'
                inputElement.classList.add('transition_cls');


                }, 400);
                setTimeout(() => {
                inputElement.style.background = '';
                inputElement.style.transform = 'scale(1)'


                }, 600);
                setTimeout(() => {
                inputElement.style.background = 'red';
                // inputElement.style.transform = 'scale(1.15)'
                inputElement.classList.add('transition_cls');


                }, 800);
            }
            setTimeout(() => {
                inputElement.style.background = '';
                inputElement.style.transform = 'scale(1)'


            //    inputElement.value = '';
            }, 1000);
            inputElement.style.border = 'revert';
        // inputElement.style.border = 'revert';
      }

        function addMarkerAgain(x, y) {

            addMarkernew(x, y)
        }


        function set_marked_positions() {
            if (page_mode == 'realtime') {
                $.ajax({
                    type: 'GET',
                    url: '/set_marker',
                    contentType: 'application/json',
                    success: function (data) {
                        var marker_data = 0
                        if (marker_data < 5) {
                            for (var i = 0; i < data.length; i++) {
                                if (chartMarker[i]) {
                                    chartMarker[i].dispose()
                                }
                                var j = 0
                                local_store = data;
                                if (data[i].frequency != null) {
                                    counter = data.length - 1
                                    if (mark_data_flag == true) {
                                        chartMarker[i] = chart.addChartMarkerXY().setPosition({ x: data[i].frequency, y: data[i].power })
                                        chartMarker[i].setPointMarker(marker => marker.setShape(PointShape.Diamond).setSize({ x: 12, y: 12 }).setFillStyle(new SolidFill({ color: ColorHEX(`${marker_color}`) }))).setResultTableVisibility(UIVisibilityModes.always).setGridStrokeXCut(true).setGridStrokeYCut(true).setResultTable((table) => table.setContent([[`M${data[i].marker_index + 1}`]])).setGridStrokeXVisibility(UIVisibilityModes.always).setGridStrokeYVisibility(UIVisibilityModes.always).setTickMarkerXVisibility(UIVisibilityModes.always).setTickMarkerYVisibility(UIVisibilityModes.always).setGridStrokeXStyle(new DashedLine({ fillStyle: new SolidFill({ color: ColorHEX("#a639f9") }) })).setGridStrokeYStyle(new DashedLine({ fillStyle: new SolidFill({ color: ColorHEX("#a639f9") }) }))
                                        addMarkerData.push({ x: data[i].frequency, y: data[i].power });
                                        pos_x[i] = data[i].frequency
                                    }
                                    else {

                                        hide_markers(data)

                                    }

                                }
                                else {
                                    if (!window.parent.removed_marker.includes(i)) {
                                        window.parent.removed_marker.push(i)
                                    }

                                }


                                marker_data = marker_data + 1
                            }
                        }
                    }
                })
            }
            else {
                $.ajax({
                    type: 'GET',
                    url: '/set_marker_sweep',
                    contentType: 'application/json',
                    success: function (data) {
                        var marker_data = 0
                        var start_freq = parseFloat((parent.document.getElementById('Start_number').value));
                        var stop_freq = parseFloat((parent.document.getElementById('Stop_number').value))
                        if (marker_data < 5) {
                            for (var i = 0; i < data.length; i++) {
                                if (chartMarker[i]) {
                                    chartMarker[i].dispose()
                                }
                                var j = 0
                                local_store = data;
                                
                                if (data[i].frequency != null ) {
                                    console.log(parseFloat((parent.document.getElementById('Start_number').value)).toFixed(3) , data[i].frequency.toFixed(3) , parseFloat((parent.document.getElementById('Stop_number').value)).toFixed(3))
                                    if( start_freq > data[i].frequency.toFixed(3) || data[i].frequency.toFixed(3) > stop_freq){
                                        window.parent.removed_marker.push(i)
                                        // window.parent.remove_marker(`M_${i}`)
                                        // console.log('removed',data[i].frequency.toFixed(3))
                                    }
                                    else{
                                        // console.log('added',data[i].frequency.toFixed(3))

                                            counter = data.length - 1
                                        if (mark_data_flag == true) {
                                            chartMarker[i] = chart.addChartMarkerXY().setPosition({ x: data[i].frequency, y: data[i].power })
                                            chartMarker[i].setPointMarker(marker => marker.setShape(PointShape.Diamond).setSize({ x: 12, y: 12 }).setFillStyle(new SolidFill({ color: ColorHEX(`${marker_color}`) }))).setResultTableVisibility(UIVisibilityModes.always).setGridStrokeXCut(true).setGridStrokeYCut(true).setResultTable((table) => table.setContent([[`M${data[i].marker_index + 1}`]])).setGridStrokeXVisibility(UIVisibilityModes.always).setGridStrokeYVisibility(UIVisibilityModes.always).setTickMarkerXVisibility(UIVisibilityModes.always).setTickMarkerYVisibility(UIVisibilityModes.always).setGridStrokeXStyle(new DashedLine({ fillStyle: new SolidFill({ color: ColorHEX("#a639f9") }) })).setGridStrokeYStyle(new DashedLine({ fillStyle: new SolidFill({ color: ColorHEX("#a639f9") }) }))
                                            addMarkerData.push({ x: data[i].frequency, y: data[i].power });
                                            pos_x[i] = data[i].frequency
                                        }
                                        else {
    
                                            hide_markers(data)
    
                                        }
                                    }

                                }
                                else {
                                    if (!window.parent.removed_marker.includes(i)) {
                                        window.parent.removed_marker.push(i)
                                    }

                                }

                                if(i == data.length-1){
                                    remove_marker_using_list(window.parent.removed_marker)
                                }
                                marker_data = marker_data + 1
                            }
                        }
                    }
                })


            }
        }


        function remove_marker_using_list(marker_list) {
            var data = {
            'index_list': marker_list
            }
            $.ajax({
            type: 'POST',
            url: '/remove_marker_using_list_sweep',
            data: JSON.stringify(data),
            contentType: 'application/json',
            success: function (data) {
                parent.marked_positions_table()
            }
            });
        }


        function hide_markers(data) {
            for (var i = 0; i < data.length; i++) {
                if(chartMarker[i]){
                    if (chartMarker[i].getVisible()) {
                        chartMarker[i].setVisible(false);
                    }
                }
            }
        }


        series.onMouseDown((_, e) => {
            if (event.button !== 2) return
            rightMbPress = performance.now()
        });

        series.onMouseUp((_, e) => {
            if (!rightMbPress || performance.now() - rightMbPress > 500) return
            const locationAxis = chart.translateCoordinate(event, chart.coordsAxis)
            var x = locationAxis.x
            var y = locationAxis.y
            addMarkernew(x, y)
        })

        // =============================================== update Markar =================================================


        function update_marker(i) {

            if (chartMarker[i]) {
                var pos = chartMarker[i].getPosition()
                pos_in_hz = pos.x * 1e6
                if (dataVal.x) {
                    var index = findClosest(dataVal.x, pos_in_hz)
                    chartMarker[i].setPosition({ x: pos.x, y: dataVal.y[index.index] })
                    window.parent.update_power(i, dataVal.y[index.index])
                }
            }

            if (pos_x[i]) {
                // console.log(i)
                chartMarker[i].getPointMarker().onMouseDragStop(() => {
                    if (chartMarker[i]) {
                        // new_pos[i] = new_pos_q
                        new_pos[i] = chartMarker[i].getPosition().x
                        if (pos_x[i] != new_pos[i]) {
                            // console.log("hello",new_pos[i])
                            pos_x[i] = new_pos[i];
                            data = chartMarker[i].getPosition()
                            var frequency
                            var power
                            var marker_name
                            var data1 = {
                                frequency: data.x,
                                power: data.y,
                                'marker_index': i,
                                'color': '#FFFFFF'
                            }

                            if (page_mode == 'realtime') {
                                $.ajax({
                                    type: 'POST',
                                    url: "/get_marker_sweep",
                                    contentType: 'application/json',
                                    data: JSON.stringify(data1),
                                    dataType: 'json',
                                    success: function (data) {
                                      // console.log("updated")
                                        parent.update_freq(i, chartMarker[i].getPosition().x)
                                        // set_marked_positions()
                                    },
                                    error: function (xhr, status, error) {
                                        console.error("Error :", error);
                                    },
                                });
                            }
                            else {
                                $.ajax({
                                    type: 'POST',
                                    url: "/get_marker_sweep",
                                    contentType: 'application/json',
                                    data: JSON.stringify(data1),
                                    dataType: 'json',
                                    success: function (data) {
                                      // console.log("updated")
                                        parent.update_freq(i, chartMarker[i].getPosition().x)
                                        // set_marked_positions()
                                    },
                                    error: function (xhr, status, error) {
                                        console.error("Error :", error);
                                    },
                                });
                            }


                        }
                    }

                });

                chartMarker[i].getTickMarkerX().onMouseDragStop(() => {
                    if (chartMarker[i]) {
                        // new_pos[i] = new_pos_q
                        new_pos[i] = chartMarker[i].getPosition().x
                        if (pos_x[i] != new_pos[i]) {
                            // console.log("hello",new_pos[i])
                            pos_x[i] = new_pos[i];
                            data = chartMarker[i].getPosition()
                            var frequency
                            var power
                            var marker_name
                            var data1 = {
                                frequency: data.x,
                                power: data.y,
                                'marker_index': i,
                                'color': '#FFFFFF'
                            }
                            if (page_mode == 'realtime') {
                                $.ajax({
                                    type: 'POST',
                                    url: "/get_marker_sweep",
                                    contentType: 'application/json',
                                    data: JSON.stringify(data1),
                                    dataType: 'json',
                                    success: function (data) {
                                      // console.log("updated")
                                        parent.update_freq(i, chartMarker[i].getPosition().x)
                                        // set_marked_positions()
                                    },
                                    error: function (xhr, status, error) {
                                        console.error("Error :", error);
                                    },
                                });
                            }
                            else {
                                $.ajax({
                                    type: 'POST',
                                    url: "/get_marker_sweep",
                                    contentType: 'application/json',
                                    data: JSON.stringify(data1),
                                    dataType: 'json',
                                    success: function (data) {
                                      // console.log("updated")
                                        parent.update_freq(i, chartMarker[i].getPosition().x)
                                        // set_marked_positions()
                                    },
                                    error: function (xhr, status, error) {
                                        console.error("Error :", error);
                                    },
                                });
                            }
                        }
                    }
                });
            }
        }


        function findClosest(arr, target) {
            let n = arr.length;
            let i = 0, j = n - 1, mid = 0;

            // Corner cases
            if (target <= arr[0]) {
                return { "val": arr[0], "index": 0 };
            }
            if (target >= arr[n - 1]) {
                return { "val": arr[n - 1], "index": n - 1 };
            }

            // Binary search
            while (i <= j) {
                mid = Math.floor((i + j) / 2);

                // If target is found, return it immediately
                if (arr[mid] === target) {
                    return { "val": arr[mid], "index": mid };
                }

                // If target is less than arr[mid], search in the left half
                if (target < arr[mid]) {
                    j = mid - 1;
                }
                // If target is greater than arr[mid], search in the right half
                else {
                    i = mid + 1;
                }
            }

            // After binary search, i is the first element greater than the target
            // and j is the last element less than the target.
            // We compare the closest two values arr[j] and arr[i]
            if (i < n && arr[i] === target) {
                return { "val": arr[i], "index": i };
            }
            if (j >= 0 && arr[j] === target) {
                return { "val": arr[j], "index": j };
            }

            // Now determine the closest value
            let left = arr[j] !== undefined ? arr[j] : Infinity;
            let right = arr[i] !== undefined ? arr[i] : Infinity;

            if (Math.abs(target - left) <= Math.abs(target - right)) {
                return { "val": left, "index": j };
            } else {
                return { "val": right, "index": i };
            }
        }


        window.parent.document.addEventListener('fullscreenchange', exitHandler);
        window.parent.document.addEventListener('webkitfullscreenchange', exitHandler);
        window.parent.document.addEventListener('mozfullscreenchange', exitHandler);
        window.parent.document.addEventListener('MSFullscreenChange', exitHandler);


        function exitHandler() {
            if (!window.parent.document.fullscreenElement && !window.parent.document.webkitIsFullScreen && !window.parent.document.mozFullScreen && !window.parent.document.msFullscreenElement) {
                if (!parent.table_full) {
                    document.getElementById('full_screen_icon').classList.remove('fa-compress')
                    document.getElementById('full_screen_icon').classList.add('fa-expand')
                    parent.full_iframe = false;
                }

            }
            else {
                if (!parent.table_full) {
                    document.getElementById('full_screen_icon').classList.remove('fa-expand')
                    document.getElementById('full_screen_icon').classList.add('fa-compress')
                    parent.full_iframe = true;
                }
            }
        }

    


        function open_loader() {
            $('#websocket_loader').modal('show')
        }


        function close_loader() {
            $('#websocket_loader').modal('hide')
        }

        
        function realtime_iq_data(channel) {
            
            realtime_ws_config[channel]['ws_obj'] = new WebSocket("ws://" + document.domain + ":" + realtime_ws_config[channel]['port'] );
            realtime_ws_config[channel]['ws_obj'] .onopen = onWsPlotOpened;
            // ws_r[name].onmessage = onWsPlotRecv;
            // ws_r[name].onclose = onWsPlotClosed;
            // ws_r.onerror = onWsPlotError;
            realtime_ws_config[channel]['ws_obj'] .binaryType = "arraybuffer";

                window.onbeforeunload = () => {
                    realtime_ws_config[channel]['ws_obj'] .onclose = () => { };
                    realtime_ws_config[channel]['ws_obj'] .close();
                };
            }


            // function onWsPlotRecv(evt) {
            // dataVal = JSON.parse(evt.data);
            // data['realtime_data'].forEach(i => {
            //     if (ws_r[i['channel']]) {
            //         // console.log(dataVal['message'])
            //         if (dataVal['message']=="connected"){
            //           console.log("connected CH2")
            //         }
            //     }

            // });
            // }


            // function onWsPlotClosed(name) {
            //     setTimeout(realtime_iq_data(name), 500);
            //     data['realtime_data'].forEach(i => {
            //     });
            // }


            function onWsPlotError() {
                console.error("WebSocket error.");
            }

            function onWsPlotOpened(evt) {
                var url = (evt.target.url).split(":")
                var wss_port = url[2].slice(0, url[2].length-1)
                for (const [key, value] of Object.entries(realtime_ws_config)) {
                    if(value['port'] == wss_port){
                        console.log("REALTIME CONFIG DATA :: " , evt)
                        console.log("REALTIME CHANNEL OPENED")
                        try {
                            if (value['ws_obj']) {
                                value['ws_obj'].send("connected");
                                console.log("Success")
                            }

                        } catch (e) {
                            console.log("Hi",e)
                        }
                    }
                }
            }


        $(document).ready(function () {
            open_loader()
            setTimeout(function () {
                window.parent.iq_data()

            }, 500)
        });


        collapse_trace("dwn")
        waterfall_XYAxis()
        set_threshold(spectrum_data['threshold'])
        // set_marked_positions();
        traces_setting()

    </script>
</body>


{% endblock %}